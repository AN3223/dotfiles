#!/usr/bin/env raku

# XXX call this script from a Makefile and maintain a text file of SSIMs for each shader
# XXX implement maximization
# XXX implement downscaling
# XXX support testing on non-yuv420p?
# XXX add option to test multiple planes at a time? (sounds like a pain)
# XXX make a script for plotting stats files
# XXX document this script better
# XXX add a way to specify multiple test media files (dir?) & concat them all for performance

use MONKEY-SEE-NO-EVAL;
use soft;

my %gbl;
my %tmp;
END %tmp.values.flat.map(&unlink);

my $ffmpeg = "ffmpeg -nostdin -y";
my $ffv1 = "-c:v ffv1 -pix_fmt yuv420p";

&run.wrap(sub (*@args, *%opts) returns Proc {
	# drop stderr and/or stdout if they aren't requested
	%opts<out> = False without %opts<out>;
	%opts<err> = False without %opts<err>;
	@args.note if %gbl<verbose>;
	if %gbl<dry-run> {
		@args.note if not %gbl<verbose>;
		callwith <true>, :out(False), :err(False);
	} elsif my $proc = callwith(|@args, |%opts) {
		$proc;
	} else {
		# print stdout & stderr on error
		note($proc.out.slurp(:close)) with $proc.out;
		note($proc.err.slurp(:close)) with $proc.err;
		die 'command failed: ' ~ @args;
	}
});

# takes a list of hashes outputs an average of their keys
sub hashavg(@hashes) returns Hash() {
	@hashes.reduce({$^acc >>+<< $^x}).map({$_ >>/>> @hashes.elems});
}

sub avgssim(Str $out) returns Hash {
	hashavg($out.split("\n", :skip-empty).map({
		.split(' ')[1..*-2].map({.split(':')}).flat.hash
	}))
}

sub run_cfg(Str $cfgopts) returns Str {
	my $in-shader = open %gbl<shader>;
	my $out-shader;
	loop { # ensure a unique filename
		try { $out-shader = open(sprintf("%s.%d.glsl", %gbl<tmp>, 999.rand.Int), :rx); }
		last if not $!;
		$!.note if %gbl<verbose>;
	}
	my $path = $out-shader.IO.path;
	LEAVE { $out-shader.close; $in-shader.close; }

	given %gbl<shader> {
		when /nlmeans/ {
			run <./nlmeans_cfg>, :in($in-shader), :out($out-shader),
				:env("NLM_{%gbl<plane> eq 'LUMA' ?? 'LUMA' !! 'CHROMA'}" => $cfgopts,
					"NLM_OPTS" => "HOOKS=%gbl<plane>");
		}
		when /guided/ {
			run <./guided_cfg>, :in($in-shader), :out($out-shader),
				:env("GUIDED_OPTS" => "$cfgopts\:HOOKS=%gbl<plane>");
		}
	}

	%tmp{$path} = $path;
}

sub shader_ssim(Str $in1, Str $in2, Str $shader) returns Str {
	my $vf = "hwupload,libplacebo=custom_shader_path=$shader,hwdownload,format=yuv420p[placebo]; [placebo]ssim=-";
	my $proc = run <<$ffmpeg -i "$in1" -i "$in2" -init_hw_device "%gbl<vk>" -lavfi "$vf" -f null ->>, :out;
	$proc.out.slurp(:close);
}

sub stats($cfgopts, %ssim) {
	my $s = "$cfgopts Y %ssim<Y> U %ssim<U> V %ssim<V> All %ssim<All>\n";
	print("$s");
	%gbl<statsfile>.print($s);
	%gbl<statsfile>.flush;
}

sub concat_realizations() {
	note('Concatenating corrupt test media files...');
	my $new-corrupt = %gbl<tmp> ~ ".corrupt.mkv";
	my $vf = "concat={%tmp<corrupt>.elems},setpts=N/(FR*TB)";
	run <<$ffmpeg>>, %tmp<corrupt>.map({('-i', $_)}).flat, <<-lavfi "$vf" $ffv1 "$new-corrupt">>;
	%tmp<corrupt>.map(&unlink);
	%tmp<corrupt> := ($new-corrupt);
}

sub MAIN(
	Str $test-media,
	Str :$cfgopts = "",
	Str :$shader = "nlmeans_template",
	Str :$plane = "LUMA",
	Str :$corruption = "NOISE=10",
	Str :$tmpfile = "shader_test.tmp",
	Str :$vk-device = "vulkan",
	Str :$stats-dir = "stats",
	Int :$realizations = 10,
	Bool :$dry-run = False,
	Bool :$verbose = False,
	Bool :$no-concat = False,
	Bool :$force = False
) {
	%gbl<tmp shader dry-run verbose vk plane> = $tmpfile, $shader, $dry-run, $verbose, $vk-device, $plane;

	my @statsfile = (
		# friendly shader name
		%gbl<shader>.IO.basename.subst(/nlmeans/, "NLM").subst(/(_template$|\.glsl$)/),
		# basename of test-media w/o extension
		$test-media.IO.basename.split('.', :skip-empty)[0],
		%gbl<plane>, $corruption, "RZ=$realizations", "CAT={(!$no-concat).Int}", $cfgopts
	);
	my $statsfile = "$stats-dir/{@statsfile.join(':').trans('/' => '_')}.stats";

	if not %gbl<dry-run> {
		run <<renice -n 19 "$*PID">>; run <<ionice -c 3 -p "$*PID">>;
		if $force {
			%gbl<statsfile> = open $statsfile, :w;
		} else {
			die 'file exists' if "$statsfile.bz2".IO.e;
			try { %gbl<statsfile> = open $statsfile, :x; }
			die 'file exists' if $!;
		}
	}

	note('Encoding test media...');
	%tmp<media> = "%gbl<tmp>.mkv";
	run <<$ffmpeg -i "$test-media" $ffv1 "%tmp<media>">>;

	# XXX add a downscale corruption for testing upscalers
	# XXX add a "bring your own" corruption where you can specify your own corrupt test media
	note('Corrupting test media...');
	given $corruption {
		when /^NOISE\=/ {
			my $noise = $corruption.split('=')[1];
			%tmp<corrupt> := (^$realizations).map({"%gbl<tmp>.corrupt$_.mkv"});
			for ^$realizations {
				my $vf = "noise=alls=$noise\:all_seed=$_\:allf=t";
				run <<$ffmpeg -i "%tmp<media>" $ffv1 -vf "$vf" "%tmp<corrupt>[$_]">>;
			}
			concat_realizations() if not $no-concat;
		}
		when /^JPEG\=/ {
			my $quality = $corruption.split('=')[1];
			my $codec = "-q\:v $quality -c\:v mjpeg";
			%tmp<corrupt> = ("%gbl<tmp>.corrupt.mkv");
			run <<$ffmpeg -i "%tmp<media>" $codec "%tmp<corrupt>[0]">>;
		}
	}

	note('Measuring baseline...');
	my %baseline;
	if not %gbl<dry-run> {
		my $baseline = %tmp<corrupt>
			.map({run(<<$ffmpeg -i "%tmp<media>" -i "$_" -lavfi ssim=- -f null ->>, :out).out.slurp(:close)})
			.join("\n");
		%baseline = avgssim($baseline);
		stats "BASELINE=$corruption", %baseline;
	}

	# XXX doesn't work when only 1 parameter is specified
	# parse k=v:k=v:k=v:...
	my @cfgopts = $cfgopts.split(':', :skip-empty).map({.split('=')}).flat;
	# for restoring order after hashing; dies on duplicate keys
	my %keyorder = @cfgopts[0,2...*].unique(:with({$^x === $^y && die 'duplicate opt'})).antipairs;
	# EVAL every v in k=v:k=v:k=v:...
	my %cfgopts = @cfgopts.hash.kv.map({$^k => EVAL $^v});
	# convert to list of permutations
	@cfgopts = %cfgopts.values.reduce(&infix:<X>).map({%cfgopts.keys Z .flat});
	# convert to list of strings back to k=v:k=v:k=v:... format
	@cfgopts = @cfgopts.map({
		.sort({%keyorder{$_}}).map({.join('=')}).join(':')
	});
	# ensure non-empty
	@cfgopts = ("") if not @cfgopts;

	sprintf("Trying %d permutations...", (@cfgopts.elems || 1)).note;
	@cfgopts.note if %gbl<verbose>;

	exit if %gbl<dry-run>;

	@cfgopts.map(-> $cfgopts {
		my $shader = run_cfg($cfgopts);
		my $out = %tmp<corrupt>.map({shader_ssim($_, %tmp<media>, $shader)}).join("\n");
		unlink %tmp{$shader}:delete;
		$cfgopts => avgssim($out);
	}).list.map({stats .key, .value});

	%gbl<statsfile>.close();

	note("\nSorted worst to best:\n");
	my $proc = run <sort -k 9 -n>, :in(open %gbl<statsfile>.IO.path), :out;
	note($proc.out.slurp(:close).split("\n")[*-15..*].join("\n"));

	run <bzip2 -9>, ('-f' if $force), %gbl<statsfile>.IO.path;
}

