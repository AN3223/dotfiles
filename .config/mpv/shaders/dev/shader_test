#!/usr/bin/env raku

# XXX call this script from a Makefile and maintain a text file of SSIMs for each shader
# XXX implement maximization
# XXX support testing on non-yuv420p?
# XXX add option to test multiple planes at a time? (sounds like a pain)
# XXX make a script for plotting stats files
# XXX document this script better
# XXX proper range parsing? esp. to ensure the output type is the same as input

use MONKEY-SEE-NO-EVAL;
use soft;

my %gbl;
my %tmp;
END %tmp.values.flat.map(&unlink);

my $ffmpeg = "ffmpeg -nostdin -y";
my $ffv1 = "-c:v ffv1 -pix_fmt yuv420p";

# drop stderr and/or stdout if they aren't requested
# die and print stdout & stderr if command fails
&run.wrap(sub (*@args, *%opts --> Proc) {
	%opts<out> = True without %opts<out>;
	%opts<err> = True without %opts<err>;
	note(@args) if %gbl<verbose>;
	if %gbl<dry-run> {
		note(@args) if not %gbl<verbose>;
		Proc; # satisfy type check
	} elsif my $proc = callwith(|@args, |%opts) {
		$proc;
	} else {
		note($proc.out.slurp(:close)) with $proc.out;
		note($proc.err.slurp(:close)) with $proc.err;
		die 'command failed: ' ~ @args;
	}
});

# parses output from ffmpeg's SSIM filter and outputs an average
sub avgssim(Str $out --> Hash) {
	$out.note if %gbl<verbose>;
	$out ==> split("\n", :skip-empty)
	     ==> map({ .split(' ')[1..*-2]>>.split(':').flat.hash })
	     ==> { [>>+<<] $_ >>/>> .elems }() # hash average
}

# dispatches the appropriate cfg script (if any) w/ $cfgopts
# returns the path to the new shader
sub run_cfg(Str $cfgopts --> Str) {
	return %gbl<shader> if !$cfgopts && %gbl<shader>.IO.basename !~~ /_template$/;

	my $in-shader = open %gbl<shader>;
	my $out-shader;
	loop { # ensure a unique filename
		try { $out-shader = open("{%gbl<tmp>}.{999.rand.Int}.glsl", :rx); }
		last if not $!;
		note($!) if %gbl<verbose>;
	}
	my $path = $out-shader.IO.path;
	LEAVE { $out-shader.close; $in-shader.close; }

	given %gbl<shader> {
		when /nlmeans/ {
			run <./nlmeans_cfg>, :in($in-shader), :out($out-shader),
				:env(
					"NLM_{%gbl<plane> eq 'LUMA' ?? 'LUMA' !! 'CHROMA'}" => $cfgopts,
					"NLM_OPTS" => "HOOKS=%gbl<plane>"
				);
		}
		when /guided/ {
			run <./guided_cfg>, :in($in-shader), :out($out-shader),
				:env("GUIDED_OPTS" => "$cfgopts\:HOOKS=%gbl<plane>");
		}
	}

	%tmp{$path} = $path;
}

sub shader_ssim(Str $in1, Str $in2, Str $shader --> Str) {
	my $vf = "hwupload,libplacebo=custom_shader_path=$shader,hwdownload,format=yuv420p[placebo]; [placebo]ssim=-";
	run(<<$ffmpeg -i "$in1" -i "$in2" -init_hw_device "%gbl<vk>" -lavfi "$vf" -f null ->>, :out).out.slurp(:close);
}

sub stats($cfgopts, %ssim) {
	my $s = "$cfgopts Y %ssim<Y> U %ssim<U> V %ssim<V> All %ssim<All>\n";
	print("$s");
	%gbl<statsfile>.print($s) if %gbl<statsfile>;
}

# Concatenates or loops files and removes the originals if requested
sub vfconcat(@media, Str :$ext = "concat", Bool :$rm = False, Int :$loop = 0) {
	my $out-file = "{%gbl<tmp>}.$ext.mkv";

	run <<$ffmpeg>>,
		(<<-stream_loop $loop>> if $loop),
		@media.map({ ('-i', $_) }).flat,
		(<<-lavfi "concat={@media.elems},setpts=N/(FR*TB)">> if @media.elems > 1),
		<<$ffv1 "$out-file">>;

	@media.map(&unlink) if $rm;
	$out-file;
}

# recursive ls
sub find(IO::Path() $f --> Array()) { $f.d ?? dir($f).flatmap(&find) !! ($f) }

sub MAIN(
	*@test-media,
	Str :$cfgopts = "",
	Str :$shader where *.IO.r = "nlmeans_template",
	Str :$plane = "LUMA",
	Str :$corruption = "NOISE=10",
	Str :$tmpfile = "shader_test.tmp",
	Str :$vk-device = "vulkan",
	Str :$stats-dir where *.IO.d = "stats",
	Int :$realizations where *>0 = 10,
	Bool :$skip-stats = False,
	Bool :$dry-run = False,
	Bool :$verbose = False, Bool :$v = False,
	Bool :$no-concat = False,
	Bool :$force = False
) {
	%gbl<tmp shader dry-run verbose vk plane> = $tmpfile, $shader, $dry-run, ($verbose || $v), $vk-device, $plane;

	die 'no test media specified' if not @test-media;
	
	my @statsfile = (
		# friendly shader name
		%gbl<shader>.IO.basename.subst(/nlmeans/, "NLM").subst(/(_template$|\.glsl$)/),
		# comma delimited basenames of test-media w/o extensions
		@test-media.map({ .IO.basename.split('.', :skip-empty)[0] }).join(','),
		%gbl<plane>, $corruption, "RZ=$realizations", "CAT={(!$no-concat).Int}", $cfgopts
	);
	my $statsfile = "$stats-dir/{@statsfile.join(':').trans('/' => '_')}.stats";

	@test-media = @test-media.flatmap(&find).grep({ $_.path !~~ /\.txt$/ });
	@test-media.map({ .f || die "$_ doesn't exist or is unreadable" });

	if not %gbl<dry-run> {
		run <<renice -n 19 "$*PID">>; run <<ionice -c 3 -p "$*PID">>;
		if not $skip-stats {
			if $force {
				%gbl<statsfile> = open $statsfile, :w;
			} else {
				die 'stats file exists' if "$statsfile.bz2".IO.e;
				try { %gbl<statsfile> = open $statsfile, :x; }
				die 'stats file exists' if $!;
			}
		}
	}

	# XXX add option to downscale
	note('Encoding test media...');
	%tmp<media> = vfconcat(@test-media);

	# XXX add a downscale corruption for testing upscalers
	# XXX add a "bring your own" corruption where you can specify your own corrupt test media
	note('Corrupting test media...');
	given $corruption {
		when /^NOISE\=/ {
			my $noise = $corruption.split('=')[1];
			^$realizations ==> map({
				my $file = "{%gbl<tmp>}.corrupt$_.mkv";
				my $vf = "noise=alls=$noise\:all_seed=$_\:allf=t";
				run <<$ffmpeg -i "%tmp<media>" $ffv1 -vf "$vf" "$file">>;
				$file;
			}) ==> list() ==> %tmp<corrupt>;

			if not $no-concat { # concat corrupt media, pad test media to same length
				%tmp<corrupt> = (vfconcat(%tmp<corrupt>, :rm, :ext('corrupt')));
				%tmp<media> = vfconcat(List(%tmp<media>), :rm, :loop($realizations), :ext('looped'));
			}
		}
		when /^JPEG\=/ {
			my $quality = $corruption.split('=')[1];
			my $codec = "-q\:v $quality -c\:v mjpeg";
			%tmp<corrupt> = ("{%gbl<tmp>}.corrupt.mkv");
			run <<$ffmpeg -i "%tmp<media>" $codec "%tmp<corrupt>[0]">>;
		}
	}

	note('Measuring baseline...');
	my %baseline;
	if not %gbl<dry-run> {
		%tmp<corrupt>.map({
			run(<<$ffmpeg -i "%tmp<media>" -i "$_" -lavfi ssim=- -f null ->>, :out).out.slurp(:close)
		}).join("\n") ==> avgssim() ==> %baseline;

		stats "BASELINE=$corruption", %baseline;
	}

	my @flatopts = $cfgopts.split(/<[=:]>/, :skip-empty); # parse k=v:k=v:k=v:...
	die 'invalid cfgopts' if @flatopts.elems && not @flatopts.elems %% 2;
	my @opts = @flatopts[0,2...*].unique(:with({ $^x === $^y && die 'duplicate opt' }));
	my @values = @flatopts[1,3...*].map(&EVAL);
	my @cfgopts = do given @opts.elems {
		when 0 { ("") }
		when 1 { @values[0].map({ "@opts[0]=$_" }) }
		default {
			[X] @values ==> map({ @opts Z $_ }) # generate permutations
			            ==> map({ $_>>.join('=').join(':') }) # stringify
		}
	}

	note("Trying {@cfgopts.elems || 1} permutations...");
	note(@cfgopts.raku) if %gbl<verbose>;

	exit if %gbl<dry-run>;

	@cfgopts.map(-> $cfgopts {
		my $shader = run_cfg($cfgopts);
		my @out = %tmp<corrupt>.map({ shader_ssim($_, %tmp<media>, $shader) });
		unlink %tmp{$shader}:delete;
		$cfgopts => avgssim(@out.join("\n"));
	}).map({ stats .key, .value });

	if %gbl<statsfile> {
		%gbl<statsfile>.close();
		note("\nSorted worst to best:\n");
		run(<sort -k 9 -n>, :in(open %gbl<statsfile>.IO.path), :out)
			.out.slurp(:close).split("\n")
			==> { .elems < 15 ?? $_ !! $_[*-15..*] }() # last 15 or less
			==> join("\n") ==> note();

		run <bzip2 -9>, ('-f' if $force), %gbl<statsfile>.IO.path;
	}
}

