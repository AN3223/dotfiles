#!/usr/bin/env raku

# XXX call this script from a Makefile and maintain a text file of SSIMs for each shader
# XXX add option to test multiple planes at a time? (sounds like a pain)
# XXX make a script for plotting stats files
# XXX it may be possible to aggressively merge some calls to ffmpeg
# XXX sometimes ffmpeg hangs for a bit and then spits out a very high inaccurate SSIM

use MONKEY-SEE-NO-EVAL;
use soft;

my %gbl;
my %tmp;
END { %tmp.values.flat.map(&unlink); rmdir %gbl<tmpdir> with %gbl<tmpdir>; };

my $ffmpeg = "ffmpeg -nostdin -y";
# drop stderr and/or stdout if they aren't requested
# die and print stdout & stderr if command fails
# uses timeout(1) w/ retries to ensure process doesn't hang
&run.wrap(sub (*@args, *%opts --> Proc) {
	%opts<out> = True without %opts<out>;
	%opts<err> = True without %opts<err>;
	note(@args) if %gbl<verbose>;
	@args = (|<timeout -k 5 90>, |@args);

	my $proc;
	loop (my $i = 0; $i < 5; $i++) {
		given $proc = callwith(|@args, |%opts) {
		# timeout can return different exit codes & it shouldn't hurt to be wrong here
		# for some reason run might return Any when timed out
		when $proc === Any || $_.exitcode > 120 { note("ugh: looks like a command hung, trying again..."); }
		when $_.exitcode == 0 { return $_; }
		default { last; }
		}
	}

	with $proc {
		note($proc.out.slurp(:close)) with $proc.out;
		note($proc.err.slurp(:close)) with $proc.err;
	}
	die 'command failed: ' ~ @args;
});

# GLSL macro-safe number representation
multi sub msafe(Int $x --> Str()) { $x }
multi sub msafe(Numeric $x --> Str) { sprintf('%f', $x) }
multi sub msafe($x --> Str()) { $x }

# parses output from ffmpeg's SSIM filter and outputs an average
# XXX RGB testing is broken (not sure if it's here or somewhere else)
sub avgssim(Str $out --> FatRat) {
	$out.note if %gbl<verbose>;
	my %avg;
	$out ==> split("\n", :skip-empty)
	     ==> map({ .split(' ')[1..*-2]>>.split(':').flat.hash })
	     ==> { $_>>.FatRat }() # better precision
	     ==> { [>>+<<] $_ >>/>> .elems }() # hash average
	     ==> %avg;
	
	given %gbl<plane> {
	when 'LUMA' { return %avg<Y>; }
	when 'CHROMA' { return (%avg<U> + %avg<V>)/2; }
	default { return ([+] %avg.values) / %avg.values.elems; }
	}
}

# dispatches the appropriate cfg script (if any) w/ $cfgopts
# returns the path to the new shader
# XXX allow custom cfg scripts to be dispatched?
sub run_cfg(Str $cfgopts --> Str) {
	return %gbl<shader> if !$cfgopts && %gbl<shader>.IO.basename !~~ /_template$/;

	my $out-shader;
	loop { # ensure a unique filename
		try { $out-shader = open("{%gbl<tmp>}.{999.rand.Int}.glsl", :rx); }
		last if not $!;
		note($!) if %gbl<verbose>;
	}
	my $path = $out-shader.IO.path;
	LEAVE { $out-shader.close with $out-shader; }

	run <<./shader_cfg "{%gbl<shader>}" "OPTS=CFG_HOOKS={%gbl<plane>}\:$cfgopts">>, :out($out-shader);

	%tmp{$path} = $path;
}

sub shader_ssim(Str $in1, Str $in2, Str $shader --> Str) {
	my $vf = "hwupload,libplacebo={%gbl<resolution>.split(':')[0..1].join(':')}\:{%gbl<pix-fmt>}:custom_shader_path=$shader,hwdownload[placebo]; [placebo]ssim=-";
	run(<<$ffmpeg -i "$in1" -i "$in2" -init_hw_device "%gbl<vk>" -lavfi "$vf" -f null ->>, :out).out.slurp(:close);
}

sub stats($cfgopts, $ssim, :$erronly = False --> Pair) {
# XXX what?
# S=5:WDT=1.125000:SW=1.000000:EP=0 0.8301903091
# S=6.250000:WDT=1.125000:SW=1.000000:EP=0 0.8269018
# maximizer: changing course
# S=4.000000:WDT=1.125000:SW=1.000000:EP=0 0.8343822
# S=3.200000:WDT=1.125000:SW=1.000000:EP=0 0.8397176182
# S=2.560000:WDT=1.125000:SW=1.000000:EP=0 0.8462903455
# S=2.048000:WDT=1.125000:SW=1.000000:EP=0 0.8537578545
# S=1.638400:WDT=1.125000:SW=1.000000:EP=0 0.8611217091
# S=1.310720:WDT=1.125000:SW=1.000000:EP=0 0.8669498909
# S=1.048576:WDT=1.125000:SW=1.000000:EP=0 0.8700674
# S=0.838861:WDT=1.125000:SW=1.000000:EP=0 0.8699686545
# Use of uninitialized value element of type Any in string context.
# Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.
#   in sub stats at ./shader_test line 104
# S=1.048576:WDT=1.125000:SW=1.000000:EP=0	0.8700674
# maximizer: finished in 10 iterations
	my $s = "{$cfgopts || 'NO_CFGOPTS'} $ssim";
	if $erronly {
		note($s);
	} else {
		print("$s\n");
		%gbl<statsfile>.print("$s\n") if %gbl<statsfile>;
		%gbl<statsfile>.flush if %gbl<statsfile>;
	}
	return $cfgopts => $ssim;
}

# runs ffmpeg for testing, optionally maximizes a parameter
# XXX maybe break the maximization logic off into a separate function
sub test(Str $cfgopts, :$prev = (""=>0.0), *%state_ --> Pair) {
	my %state = %state_; # for mutating

	# set default values
	my ($m_opt, $m_start, $m_step, $m_epsilon, $m_iter) = |%gbl<max>;
	%state<value> = %state<value> || $m_start;
	%state<step> = %state<step> || $m_step;
	%state<iter> = $m_opt ?? (%state<iter> || $m_iter) !! 1;
	%state<depth> = %state<depth> || 0;
	%state<sandtrap> = %state<sandtrap> || 0;

	my $cfgopts_ = $m_opt ?? "$m_opt={msafe(%state<value>)}:$cfgopts" !! $cfgopts;
	my $shader = run_cfg($cfgopts_);
	my @out = %tmp<corrupt>.map({ shader_ssim($_, %tmp<media>, $shader) });
	unlink %tmp{$shader}:delete with %tmp{$shader};
	my $ssim = avgssim(@out.join("\n"));

	return stats($cfgopts_, $ssim) if not $m_opt;
	stats($cfgopts_, $ssim, :erronly) if $m_opt;
	return $cfgopts_ => $ssim if %state<oneshot>;

	if ++%state<depth> >= %state<iter> {
		($cfgopts_, $ssim) = $prev if $prev.value > $ssim;
		stats($cfgopts_, $ssim);
		note("maximizer: finished in %state<depth> iterations\n");
		return $cfgopts_ => $ssim;
	}

	given $prev.value {
	# XXX it's an error if the two SSIMs are the same after a course change
	when abs($ssim - $_) < $m_epsilon && !%state<course-change> {
		# XXX if the optimal value is very very large then this behaves horribly (E on guided LGC)
		note("maximizer: sandtrap");
		%state<sandtrap>++;
		%state<step> = %state<step>**%state<step>;
		%state<step> = 1/%state<step> if $ssim < $_; # estimate best travel direction
		return test($cfgopts, |%state, :prev($cfgopts_ => $ssim), :value(%state<value> * %state<step>**2));
	}
	when $ssim > $_ { # just keep going
		%state<step> *= %state<step>; # XXX should probably scale with SSIM somehow
		return test($cfgopts, |%state, :prev($cfgopts_ => $ssim), :value(%state<value> * %state<step>));
	}
	when $ssim < $_ {
		if %state<depth> <= 2 { # handle overestimates
			note("maximizer: changing course");
			%state<step> = 1/%state<step>;
			%state<course-change> = True;
			return test($cfgopts, |%state, :prev($prev), :value(%state<value> * %state<step>**2));
		}

		note("maximizer: starting binary search");

		my %max := {value => %state<value> / %state<step>, result => $prev};
		# XXX would be more fast/accurate to have a step size for both sides of the binary search, now that step is squared instead of factored
		my $step_sz = %state<value> - %max<value>;
		loop (my $i = 1 ;; $i++) {
			my $substep = $step_sz/($i*2);
			my @tests = [];
			@tests.push(%max);

			my $done = False;
			for [%max<value> + $substep, %max<value> - $substep] -> $incr {
				@tests.push({value=>$incr, result=>test($cfgopts, |%state, :value($incr), :oneshot)});
				@tests.=sort: *<result>.value;
				%max := @tests[*-1];

				$done = True if ++%state<depth> >= %state<iter>;
				$done = True if abs(%max<result>.value - @tests[*-2]<result>.value) < $m_epsilon;
				last if $done;
			}
			last if $done;
		}
		stats %max<result>.key, %max<result>.value;
		note("maximizer: finished in %state<depth> iterations\n");
		return %max<result>;
	}
	}
}

# Concatenates or loops files and removes the originals if requested
sub vfconcat(@media, Str :$ext = "concat", Bool :$rm = False, Int() :$loop = 0) {
	my $out-file = "{%gbl<tmp>}.$ext.mkv";

	run <<$ffmpeg>>,
		(<<-stream_loop $loop>> if $loop),
		@media.map({ ('-i', $_) }).flat,
		(<<-lavfi "concat={@media.elems},setpts=N/(FR*TB)">> if @media.elems > 1),
		<<%gbl<ffv1> "$out-file">>;

	@media.map(&unlink) if $rm;
	$out-file;
}

# recursive ls
sub find(IO::Path() $f --> Array()) { $f.d ?? dir($f).flatmap(&find) !! ($f) }

sub MAIN(
	#= script for testing the SSIM between corrupt->filtered image and the original image
	*@test-media, #= Files/directories to test on
	Str :$cfgopts = "", #= Arguments passed to the dispatched _cfg script, if dispatched
	Str :$shader where *.IO.r = "nlmeans_template", #= Shader used for testing
	Str :$plane = "LUMA", #= Plane to test on
	Str :$corruption = "NOISE=10:10", #= Corruption type, can be NOISE, JPEG, or SCALE
	Str :$vk-device = "vulkan", #= Device name passed to ffmpeg's -init_hw_device option
	Str :$stats-dir where *.IO.d = "stats", #= Directory where stats will be stored
	Str :$max = "", #= Maximize a parameter, syntax goes PARAM:ESTIMATE:STEP_FACTOR:EPSILON:ITERATION_LIMIT
	Str :$pix-fmt = "yuv444p", #= Pixel format used for everything
	Str :$colorspace = "bt709", #= Colorspace used for everything
	Str :$resolution where /^\d+ ':' \d+$/ = "1080:1080", #= Resolution used for everything
	Str :$tmpdir where *.IO.d = '/dev/shm', #= Directory for temporary files
	Bool :$no-stats = False, #= Skip writing to a stats file (still requires a real --stats-dir)
	Bool :$verbose = False, Bool :$v = False, #= Verbose output for debugging
	Bool :$no-concat = False, #= Skip concatenation step, very slow but may be necessary for temporal testing
	Bool :$force = False #= Force overwrite the stats file
) {
	%gbl<shader verbose vk plane resolution> = $shader, ($verbose || $v), $vk-device, $plane, $resolution;
	%gbl<ffv1 pix-fmt> = "-c:v ffv1 -colorspace $colorspace -pix_fmt $pix-fmt", $pix-fmt, $colorspace;
	%gbl<max> = roundrobin($max.split(':'), ":10:1.25:1e-6:10".split(':')).map({ $_[0] || $_[1] }).list;

	die 'no test media specified' if not @test-media;

	%gbl<tmpdir> = run(<<mktemp -d "$tmpdir/shader_test.XXXXXX">>, :out).out.slurp(:close).subst("\n");
	%gbl<tmp> = %gbl<tmpdir> ~ '/shader_test.tmp';
	
	# XXX maybe just derive the filename from ARGV instead?
	my @statsfile = (
		# friendly shader name
		%gbl<shader>.IO.basename.subst(/nlmeans/, "NLM").subst(/(_template$|\.glsl$)/),
		# comma delimited basenames of test-media w/o extensions
		@test-media.map({ .IO.basename.split('.', :skip-empty)[0] }).join(','),
		%gbl<plane>, $corruption, %gbl<resolution>.subst(':', 'x'), %gbl<pix-fmt>,
		"CAT={(!$no-concat).Int}", "MAX={%gbl<max>.join(':')}", $cfgopts
	);
	my $statsfile = "$stats-dir/{@statsfile.join(':').trans('/' => '_')}.stats";

	@test-media = @test-media.flatmap(&find).grep({ $_.path !~~ /\.txt$/ });
	@test-media.map({ .f || die "$_ doesn't exist or is unreadable" });

	run <<renice -n 19 "$*PID">>; run <<ionice -c 3 -p "$*PID">>;
	if not $no-stats {
		if $force {
			%gbl<statsfile> = open $statsfile, :w;
		} else {
			die 'stats file exists' if "$statsfile.bz2".IO.e;
			try { %gbl<statsfile> = open $statsfile, :x; }
			die 'stats file exists' if $!;
		}
	}
	note('Encoding test media...');
	%tmp<media> = vfconcat(@test-media);

	# XXX add a "bring your own" corruption where you can specify your own corrupt test media
	# XXX allow for multiple corruptions at once
	note('Corrupting test media...');
	given $corruption.split('=') {
	when $_[0] eq "NOISE" { # NOISE=NOISE_LEVEL:REALIZATIONS
		# XXX filtergraph is very long, use -filter_complex_script instead
		my ($noise, $realizations) = $_[1].split(':');
		my $split-vf = "split=$realizations" ~ (do "[s$_]" for ^$realizations).join();
		my @noise-vf = do "[s$_]noise=alls=$noise\:all_seed=$_\:allf=t[n$_]" for ^$realizations;
		my $concat-vf = (do "[n$_]" for ^$realizations).join() ~ "concat=$realizations,setpts=N/(FR*TB)";
		my $vf = ($split-vf, @noise-vf.join(";"), $concat-vf if not $no-concat).join(";");
		if $no-concat {
			%tmp<corrupt> = do "{%gbl<tmp>}.corrupt$_.mkv" for ^$realizations;
		} else {
			%tmp<corrupt> = "{%gbl<tmp>}.corrupt.mkv";
		}
		run <<$ffmpeg -i "%tmp<media>" %gbl<ffv1> -lavfi "$vf">>, %tmp<corrupt>;
	}
	when $_[0] eq "JPEG" { # JPEG=QUALITY
		my $codec = "-q\:v {$_[1]} -c\:v mjpeg";
		%tmp<corrupt> = ("{%gbl<tmp>}.corrupt.mkv");
		run <<$ffmpeg -i "%tmp<media>" $codec "%tmp<corrupt>[0]">>;
	}
	when $_[0] eq "SCALE" { # SCALE=WIDTH:HEIGHT:SCALE_OPTS
		%tmp<corrupt> = ("{%gbl<tmp>}.corrupt.mkv");
		run <<$ffmpeg -i "%tmp<media>" -vf "scale={$_[1..*].join('=')}" {%gbl<ffv1>} "%tmp<corrupt>[0]">>;
	}
	when $_[0] eq "FORMAT" { # FORMAT=FORMAT
		%tmp<corrupt> = ("{%gbl<tmp>}.corrupt.mkv");
		run <<$ffmpeg -i "%tmp<media>" {%gbl<ffv1>} -vf "format=$_[1]" "%tmp<corrupt>[0]">>;
	}
	}

	note('Measuring baseline...');
	# XXX baseline should be generated from libplacebo upscaling
	my $baseline = avgssim(%tmp<corrupt>.map({
		run(<<$ffmpeg -i "$_" -i "%tmp<media>" -lavfi "scale={%gbl<resolution>},ssim=-" {%gbl<ffv1>} -f null ->>, :out).out.slurp(:close)
	}).join("\n"));
	stats "BASELINE=$corruption", $baseline;

	my @flatopts = $cfgopts.split(/<[=:]>/, :skip-empty); # parse k=v:k=v:k=v:...
	die 'invalid cfgopts' if @flatopts.elems && not @flatopts.elems %% 2;
	my @opts = @flatopts[0,2...*].unique(:with({ $^x === $^y && die 'duplicate opt' }));
	my @values = @flatopts[1,3...*].map(&EVAL);
	my @cfgopts = do given @opts.elems {
		when 0 { ("") }
		when 1 { @values[0].map({ "@opts[0]=$_" }) }
		default {
			[X] @values ==> map({ @opts Z $_ }) # generate permutations
			            ==> map({ $_>>.map(&msafe)>>.join('=').join(':') }) # stringify
		}
	}

	note("Trying {@cfgopts.elems || 1} permutations...");
	note(@cfgopts.raku) if %gbl<verbose>;

	@cfgopts.map(&test);

	if %gbl<statsfile> {
		%gbl<statsfile>.close();
		note("\nSorted worst to best:\n");
		run(<sort -k 2 -n>, :in(open %gbl<statsfile>.IO.path), :out)
			.out.slurp(:close).split("\n")
			==> { .elems < 15 ?? $_ !! $_[*-15..*] }() # last 15 or less
			==> join("\n") ==> note();

		run <bzip2 -9>, ('-f' if $force), %gbl<statsfile>.IO.path;
	}
}

