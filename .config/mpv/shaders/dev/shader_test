#!/usr/bin/env raku

# XXX call this script from a Makefile and maintain a text file of SSIMs for each shader
# XXX hide all ffmpeg output unless there is an error
# XXX implement minimization
# XXX print all commands during --dry-run

use MONKEY-SEE-NO-EVAL;
use soft;

my $cmd-pre;
my $vulkan;

my %tmp;
END %tmp.values.flat.map(&unlink);

my $ffmpeg = "ffmpeg -nostdin -y";
my $x265 = "-c:v libx265 -x265-params lossless=1 -pix_fmt yuv420p";

# prints stdout & stderr on error, drops stdout & stderr if they aren't requested
&run.wrap(sub (*@args, *%opts) {
	my %opts_ = %opts;
	%opts_<out err> = %opts<out> || True, %opts<err> || True;

	if my $proc = callwith(|@args, |%opts_) {
		$proc.out.slurp(:close) if !%opts<out>;
		$proc.err.slurp(:close) if !%opts<err>;
		$proc;
	} else {
		note($proc.out.slurp(:close));
		note($proc.err.slurp(:close));
		die 'command failed';
	}
});

# XXX is it possible to support pixel formats other than yuv420p?
sub shader_ssim(Str $in1, Str $in2, Str $shader, Str $tmpfile) {
	my $vf = "hwupload,libplacebo=custom_shader_path=$shader,hwdownload,format=yuv420p[placebo];";
	my $null = '-f null -';
	my $proc = run <<$cmd-pre $ffmpeg -i "$in1" -i "$in2" $vulkan -lavfi "$vf [placebo]ssim=-" $null>>, :out;
	# XXX
}

sub parse_ssim(Str $out) returns List {
	$out.split("\n", :skip-empty).map({
		.split(' ')[1..*-2].map({.split(':')}).flat.hash
	}).list
}

# takes a list of parse_ssim outputs and returns a single hash of averages
sub avg_ssim(@ssims) returns Hash {
	@ssims.map({.reduce(-> $frame_acc, $frame {
		$frame_acc.map({.key => .value + $frame{.key}})
			.map({.key => .value / @ssims[0].elems})
	})}).reduce(-> $realization_acc, $realization {
		$realization_acc.map({.key => .value + $realization{.key}})
	}).map({.key => .value / @ssims.elems}).hash
}

sub MAIN(
	Str $test-media,
	Str :$cfgopts = "",
	Str :$plane = "LUMA",
	Int :$realizations = 10,
	Str :$corruption = "NOISE=10",
	Str :$statsfile = "shader_test.stats",
	Str :$tmpfile = "shader_test.tmp",
	Str :$vk-device = "vulkan",
	Bool :$dry-run = False
) {
	run <<renice -n 19 "$*PID">>; run <<ionice -c 3 -p "$*PID">>;

	$cmd-pre = $dry-run ?? "echo" !! "";
	$vulkan = "-init_hw_device $vk-device";

	# parse k=v:k=v:k=v:...
	my @cfgopts = $cfgopts.split(':', :skip-empty).map({.split('=')}).flat;
	# for restoring order after hashing; dies on duplicate keys
	my %keyorder = @cfgopts[0,2...*].unique(:with({$^x === $^y && die 'duplicate opt'})).antipairs;
	# EVAL every v in k=v:k=v:k=v:...
	my %cfgopts = @cfgopts.hash.kv.map({$^k => EVAL $^v});
	# convert to list of permutations
	@cfgopts = %cfgopts.values.reduce(&infix:<X>).map({%cfgopts.keys Z .flat});
	# convert to list of strings back to k=v:k=v:k=v:... format
	@cfgopts = @cfgopts.map({
		.sort({%keyorder{$_}}).map({.join('=')}).join(':')
	});

	note('Encoding test media...');
	%tmp<media> = "$tmpfile.mkv";
	run <<$cmd-pre $ffmpeg -i "$test-media" $x265 "%tmp<media>">>;

	note('Corrupting test media...');
	given $corruption {
		# XXX optionally allow for multiple realizations in 1 file
		when /^NOISE\=/ {
			my $noise = $corruption.split('=')[1];
			%tmp<corrupt> := (^$realizations).map({"$tmpfile.corrupt$_.mkv"});
			for ^$realizations {
				my $vf = "noise=alls=$noise\:all_seed=$_";
				run <<$cmd-pre $ffmpeg -i "%tmp<media>" $x265 -vf "$vf" "%tmp<corrupt>[$_]">>;
			}
		}
		when /^JPEG\=/ {
			my $quality = $corruption.split('=')[1];
			my $codec = "-q\:v $quality -c\:v mjpeg";
			%tmp<corrupt> = ("$tmpfile.corrupt.mkv");
			run <<$cmd-pre $ffmpeg -i "%tmp<media>" $codec "%tmp<corrupt>[0]">>;
		}
	}

	my $vf-ssim = "-lavfi ssim=- -f null -";
	my @baseline = %tmp<corrupt>
		.map({run <<$cmd-pre $ffmpeg -i "%tmp<media>" -i "$_" $vf-ssim>>, :out})
		.map({parse_ssim(.out.slurp(:close))});
	@baseline = avg_ssim(@baseline.flat);

	note("Trying " ~ (@cfgopts.elems || 1) ~ " permutations...");
}

