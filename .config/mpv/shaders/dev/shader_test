#!/usr/bin/env raku

# XXX call this script from a Makefile and maintain a text file of SSIMs for each shader
# XXX add option to test multiple planes at a time? (sounds like a pain)
# XXX make a script for plotting stats files

use MONKEY-SEE-NO-EVAL;
use soft;

my %gbl;
my %tmp;
END { %tmp.values.flat.map(&unlink); rmdir %gbl<tmpdir> with %gbl<tmpdir>; };

my $ffmpeg = "ffmpeg -nostdin -y";
# drop stderr and/or stdout if they aren't requested
# die and print stdout & stderr if command fails
# uses timeout(1) w/ retries to ensure process doesn't hang
&run.wrap(sub (*@args, *%opts --> Proc) {
	%opts<out> = True without %opts<out>;
	%opts<err> = True without %opts<err>;
	note(@args) if %gbl<verbose>;
	@args = (|<timeout -k 5 90>, |@args);

	my $proc;
	loop (my $i = 0; $i < 5; $i++) {
		given $proc = callwith(|@args, |%opts) {
		# timeout can return different exit codes & it shouldn't hurt to be wrong here
		# for some reason run might return Any when timed out
		when $proc === Any || $_.exitcode > 120 { note("ugh: looks like a command hung, trying again..."); }
		when $_.exitcode == 0 { return $_; }
		default { last; }
		}
	}

	with $proc {
		note($proc.out.slurp(:close)) with $proc.out;
		note($proc.err.slurp(:close)) with $proc.err;
	}
	die 'command failed: ' ~ @args;
});

# GLSL macro-safe number representation
multi sub msafe(Int $x --> Str()) { $x }
multi sub msafe(Numeric $x --> Str) { sprintf('%f', $x.FatRat) }
multi sub msafe($x --> Str()) { $x }

# parses output from ffmpeg's SSIM filter and outputs an average
# XXX RGB testing is broken (not sure if it's here or somewhere else)
sub avgssim(Str $out --> FatRat) {
	$out.note if %gbl<verbose>;
	my %avg;
	$out ==> split("\n", :skip-empty)
	     ==> map({ .split(' ')[1..*-2]>>.split(':').flat.hash })
	     ==> { $_>>.FatRat }() # better precision
	     ==> { [>>+<<] $_ >>/>> .elems }() # hash average
	     ==> %avg;
	
	%avg<All>:delete;
	given %gbl<plane> {
	when 'LUMA' { return %avg<Y>; }
	when 'CHROMA' { return (%avg<U> + %avg<V>)/2; }
	default { return ([+] %avg.values) / %avg.values.elems; }
	}
}

# dispatches the appropriate cfg script (if any) w/ $cfgopts
# returns the path to the new shader
# XXX allow custom cfg scripts to be dispatched?
sub run_cfg(Str $cfgopts --> Str) {
	return %gbl<shader> if !$cfgopts && %gbl<shader>.IO.basename !~~ /_template$/;

	my $out-shader;
	loop { # ensure a unique filename
		try { $out-shader = open("{%gbl<tmp>}.{999.rand.Int}.glsl", :rx); }
		last if not $!;
		note($!) if %gbl<verbose>;
	}
	my $path = $out-shader.IO.path;
	LEAVE { $out-shader.close with $out-shader; }

	run <<./shader_cfg "{%gbl<shader>}" "OPTS=CFG_HOOKS={%gbl<plane>}\:$cfgopts">>, :out($out-shader);

	%tmp{$path} = $path;
}

# XXX should be able to handle multiple files at a time too
# XXX SSIMS aren't quite the same when batching?
sub shader_ssim($corrupt-media, @shaders) {
	my Str $res = %gbl<resolution>.split(':')[0..1].join(':');
	my Bool $batch = @shaders.elems > 1;

	my (@crptpads, @inpads);
	if $batch {
		@crptpads = do "[crpt$_]" for ^@shaders.elems;
		@inpads = do "[in$_]" for ^@shaders.elems;
	} else {
		@crptpads = "[0:v]";
		@inpads = "[1:v]";
	}

	my $vf = (
		("hwupload,split={@shaders.elems}" ~ @crptpads.join() if $batch),
		("split={@shaders.elems}" ~ @inpads.join() if $batch),
		(do @crptpads[$_.key] ~ ("hwupload," if not $batch) ~ "libplacebo=$res\:{%gbl<pix-fmt>}:custom_shader_path={$_.value},hwdownload[out{$_.key}]" for @shaders.pairs).join(";\n"),
		(do "{@inpads[$_]}[out$_]ssim={%gbl<tmpdir>}/ssim$_" for ^@shaders.elems).join(";\n")
	).join(";\n");

	spurt (%tmp<filter_script> = "{%gbl<tmp>}.filter_script"), $vf;
	run(<<$ffmpeg -i "$corrupt-media">>, |%gbl<media>, <<-init_hw_device "%gbl<vk>" -filter_complex_script "{%tmp<filter_script>}" -f null ->>);

	my @ssims;
	for ^@shaders.elems {
		@ssims.push(slurp "{%gbl<tmpdir>}/ssim$_");
		unlink "{%gbl<tmpdir>}/ssim$_";
	}
	return @ssims;
}

sub stats($cfgopts, $ssim, :$erronly = False) {
	my $s = "{$cfgopts || 'NO_CFGOPTS'} $ssim";
	if $erronly {
		note($s);
	} else {
		print("$s\n");
		%gbl<statsfile>.print("$s\n") if %gbl<statsfile>;
		%gbl<statsfile>.flush if %gbl<statsfile>;
	}
	return;
}

my Int $test_len = 0;
sub run_tests(*@cfgopts --> List) {
	my @shaders = @cfgopts.map(&run_cfg);

	my @outs;
	for %tmp<corrupt><> -> $corrupt {
		# rerun batch until lengths match to work around intermittent libplacebo(?) failure
		my (@ssims, @linec);
		repeat {
			@ssims = shader_ssim($corrupt, @shaders);
			@linec = List(@ssims.map({ .split("\n").elems }));
			$test_len = @linec[0] if not $test_len and @linec[0] == all(@linec);
		} until $test_len == all(@linec);

		# join ssim outputs for each file
		for @ssims.kv -> $i, $ssim {
			@outs[$i] = join("\n", (@outs[$i] if @outs[$i]), $ssim);
		}
	}

	@shaders.map({ unlink %tmp{$_}:delete with %tmp{$_} });
	return eager @outs.map(&avgssim);
}

# XXX make the logging optional
# XXX implement a fancier optimization algorithm
sub optimize(
	&f, #= the function to optimize, takes the value and returns a list of scores
	:&cmp = { $^x > $^y }, #= true when x is more optimal than y
	:$start = 1, #= starting point for the value passed to &f
	:$first_step = 1.25, #= value is multiplied by this and it squares each iteration
	:$epsilon = 1e-6, #= exit early if the two best scores differ less than this (may be Inf)
	:$iter = 10 #= exit after this many iterations (may be Inf)
) {
	my $value = $start; # value passed to &f
	my $step = $first_step;
	my @history; # $value => $score in chronological order
	my @history_b2w; # $value => $score best to worst order
	my $course_change = False;
	my $sandtrap = 0;

	loop (my $i = 2; $i < $iter; $i++) {
	if $value < $epsilon || $value > 1/$epsilon || $value === NaN {
		note("optimizer: pointless endeavor");
		last;
	}

	my ($prev_score, $score);
	if ($i == 2) { # batch the first two tests
		@history.push(|&f($start, $value *= $step *= $step));
		($prev_score, $score) = @history.map(*.value);
	} else {
		@history.push(|&f($value));
		$prev_score = @history[*-2].value;
		$score      = @history[*-1].value;
	}
	my Bool $diff_too_small = abs($score - $prev_score) < $epsilon;
	@history_b2w = @history.sort({ not &cmp($^x.value, $^y.value) });

	if $diff_too_small && !$course_change {
		last if $sandtrap++ >= floor($iter/3);
		$step = 1/$step if not &cmp($score, $prev_score);
		$step = $step**$step;
		$value *= $step**2;
		note("optimizer: sandtrap");
	} elsif &cmp($score, $prev_score) && !$diff_too_small { # keep going
		$value *= $step *= $step;
	} else {
		if $i == 2 { # handle overestimates
			note("optimizer: changing course");
			$course_change = True;
			$step = 1/$step;
			$value *= $step**2;
			next;
		}

		note("optimizer: starting binary search");

		loop (; $i < $iter; $i += 2) {
			#
			# find the points halfway between the best known upper/lower values
			#
			# repeatedly divides by two just in case a suboptimal value exists 
			# halfway between the best known value and the best known upper/lower 
			# values
			#
			my @values = @history.map(*.key);
			my $optval = @history_b2w[0].key;
			my $lower_bound = @history_b2w.grep({ .key < $optval })[0].key;
			my $upper_bound = @history_b2w.grep({ .key > $optval })[0].key;

			# might happen if $diff_too_small && $course_change
			last if !$lower_bound.defined or !$upper_bound.defined;

			my ($lower, $upper, $j);
			$j = 1; repeat {
				$lower = $lower_bound + ($optval - $lower_bound) / (2**$j++);
			} until not $lower ∈ @values;
			$j = 1; repeat {
				$upper = $optval + ($upper_bound - $optval) / (2**$j++);
			} until not $upper ∈ @values;

			@history.push(|&f($lower, $upper));
			@history_b2w = @history.sort({ not &cmp($^x.value, $^y.value) });
			last if abs(@history_b2w[0].value - @history_b2w[1].value) < $epsilon;
		}
		last;
	}
	}

	note("optimizer: finished in $i iterations");
	return @history_b2w[0];
}

# runs ffmpeg for testing, optionally maximizes a parameter
# XXX batch this across permutations
sub test(Str $cfgopts = "") {
	my Hash @optimizer_args;
	for %gbl<max>.split(",") -> $args { 
		my %args;
		%args<option start first_step epsilon iter> = $args.split(":");
		%args.map({ %args{$^p.key}:delete without $^p.value });
		@optimizer_args.push(%args);
	}

	# S=x:SS=y:... &f(y) is optimized using an &f that optimizes &f(x)
	my Callable @optimizers;
	for @optimizer_args.kv -> $i, %args {
		my $option = %args<option>:delete;
		my $stateful = Bool($option ~~ s/^\^//);

		my &val_to_opts = -> $value, *@inject { ("$option=$value", |@inject).join(":") };
		my &f = -> *@inject {
			-> *@values {
				if @optimizers[$i-1] {
					@values.map({ $^value => @optimizers[$i-1]("$option=$^value", |@inject)().value });
				} else {
					my @cfgopts = @values.map({ &val_to_opts($^val, |@inject) });
					my @scores = run_tests(|@cfgopts);
					(@cfgopts Z=> @scores).map({ stats(.key, .value, :erronly) });
					@values Z=> @scores
				}
			}
		};
		@optimizers.push: -> *@inject {
			-> {
				my $optimal = optimize(&f(|@inject), |%args);
				if $i == 0 {
					stats(&val_to_opts($optimal.key, |@inject), $optimal.value);
					note("");
				}
				%args<start> = $optimal.key if $stateful;
				$optimal
			}
		};
	}

	if @optimizer_args {
		@optimizers[*-1]($cfgopts)();
	} else {
		stats($cfgopts, run_tests($cfgopts)[0]);
	}
}

# XXX add a "bring your own" corruption where you can specify your own corrupt test media
# XXX maybe measure baseline here?
sub corrupt(Str $corruptions, Bool $no-concat --> Int) {
	my Int $realizations = 1;
	my Str @pre-vf;
	my Callable @vf;
	my @outopts = |%gbl<outopts>;
	for $corruptions.split(',') -> $corruption {
		given $corruption.split('=') {
		when $_[0] eq "NOISE" { # NOISE=NOISE_LEVEL:REALIZATIONS
			my ($noise, $realizations_) = $_[1].split(':');
			$realizations = Int($realizations_);
			@vf.push({ "noise=alls=$noise\:all_seed=$^i\:allf=t" });
		}
		when $_[0] eq "OUTOPTS" { # OUTOPTS=OPTS
			@outopts = Array($_[1..*].join("=").split(" "));
		}
		when $_[0] eq "VF" { # VF=VF
			@pre-vf.push($_[1..*].join("="));
		}
		}
	}

	@pre-vf.push("split=$realizations");
	@vf.push({ "split=1" }) if @vf.elems == 0;
	my Str $vf = (
		@pre-vf.join(",") ~ ((do "[s$_]" for ^$realizations).join()),
		(do "[s$_]{@vf.map({ $^f($_) }).join(',')}[o$_]" for ^$realizations).join(";\n"),
		((do "[o$_]" for ^$realizations).join() ~ "concat=$realizations,setpts=N/(FR*TB)" if not $no-concat)
	).join(";\n");

	my @outs;
	if $no-concat {
		%tmp<corrupt> = do "{%gbl<tmp>}.corrupt$_.mkv" for ^$realizations;
		@outs = %tmp<corrupt>.pairs.map({ (|@outopts, "-map", "[o{$_.key}]", $_.value) }).flat;
	} else {
		%tmp<corrupt> = ("{%gbl<tmp>}.corrupt.mkv");
		@outs = (|@outopts, %tmp<corrupt>[0]);
	}

	spurt (%tmp<filter_script> = "{%gbl<tmp>}.filter_script"), $vf;
	run <<$ffmpeg -i "%tmp<media>" -filter_complex_script "{%tmp<filter_script>}">>, |@outs;

	return $realizations;
}

# recursive ls
sub find(IO::Path() $f --> Array()) { $f.d ?? dir($f).flatmap(&find) !! ($f) }

sub MAIN(
	#= script for testing the SSIM between corrupt->filtered image and the original image
	*@test-media, #= Files/directories to test on
	Str :$cfgopts = "", #= Arguments passed to the dispatched _cfg script, if dispatched
	Str :$shader where *.IO.r = "nlmeans_template", #= Shader used for testing
	Str :$plane = "LUMA", #= Plane to test on
	Str :$corruption = "NOISE=10:10", #= Corruption type, can be NOISE, JPEG, or SCALE
	Str :$vk-device = "vulkan", #= Device name passed to ffmpeg's -init_hw_device option
	Str :$stats-dir where *.IO.d = "stats", #= Directory where stats will be stored
	Str :$max = "", #= Optimizer settings: OPTION:START:STEP:EPSILON:ITER (all optional, multiple can be chained with commas)
	Str :$pix-fmt = "yuv444p", #= Pixel format used for everything
	Str :$colorspace = "bt709", #= Colorspace used for everything
	Str :$resolution where /^\d+ ':' \d+$/ = "1080:1080", #= Resolution used for everything
	Str :$tmpdir where *.IO.d = '/dev/shm', #= Directory for temporary files
	Bool :$no-stats = False, #= Skip writing to a stats file (still requires a real --stats-dir)
	Bool :$verbose = False, Bool :$v = False, #= Verbose output for debugging
	Bool :$no-concat = False, #= Skip concatenation step, very slow but may be necessary for temporal testing
	Bool :$force = False #= Force overwrite the stats file
) {
	%gbl<shader verbose vk plane resolution pix-fmt> = $shader, ($verbose || $v), $vk-device, $plane, $resolution, $pix-fmt;
	%gbl<outopts> = <<-c\:v ffv1 -colorspace "$colorspace" -pix_fmt "$pix-fmt">>;
	%gbl<max> = $max;

	die 'no test media specified' if not @test-media;

	%gbl<tmpdir> = run(<<mktemp -d "$tmpdir/shader_test.XXXXXX">>, :out).out.slurp(:close).subst("\n");
	%gbl<tmp> = %gbl<tmpdir> ~ '/shader_test.tmp';
	
	my $statsfile = "$stats-dir/"
		~ @*ARGS.grep(/^\-/).map({ S:g/^\-\-?// }).join('_').trans('/' => '\\')
		~ "_media=" ~ @test-media.map({ .IO.basename.split('.', :skip-empty)[0] }).join(',')
		~ ".stats";

	@test-media = @test-media.flatmap(&find).grep({ $_.path !~~ /\.txt$/ });
	@test-media.map({ .f || die "$_ doesn't exist or is unreadable" });

	run <<renice -n 19 "$*PID">>; run <<ionice -c 3 -p "$*PID">>;
	if not $no-stats {
		if $force {
			%gbl<statsfile> = open $statsfile, :w;
		} else {
			die 'stats file exists' if "$statsfile.bz2".IO.e;
			try { %gbl<statsfile> = open $statsfile, :x; }
			die 'stats file exists' if $!;
		}
	}
	note('Encoding test media...');
	%tmp<media> = "{%gbl<tmp>}.concat.mkv";
	run <<$ffmpeg>>, @test-media.map({ ('-i', $_) }).flat,
		(<<-lavfi "concat={@test-media.elems},setpts=N/(FR*TB)">> if @test-media.elems > 1),
		|%gbl<outopts>, %tmp<media>;

	note('Corrupting test media...');
	my $realizations = corrupt($corruption, $no-concat) - 1;
	if not $no-concat && $realizations > 0 {
		%gbl<media> = <<-stream_loop "$realizations" -i "%tmp<media>">>;
	} else {
		%gbl<media> = <<-i %tmp<media>>>;
	}

	note('Measuring baseline...');
	# XXX baseline should be generated from libplacebo upscaling
	my $baseline = avgssim(%tmp<corrupt>.map({
		run(<<$ffmpeg -i "$_">>, |%gbl<media>, <<-lavfi "scale={%gbl<resolution>},ssim=-">>, |%gbl<outopts>, <-f null ->, :out).out.slurp(:close)
	}).join("\n"));
	stats "BASELINE=$corruption", $baseline;

	my @flatopts = $cfgopts.split(/<[=:]>/, :skip-empty); # parse k=v:k=v:k=v:...
	die 'invalid cfgopts' if @flatopts.elems && not @flatopts.elems %% 2;
	my @opts = @flatopts[0,2...*].unique(:with({ $^x === $^y && die 'duplicate opt' }));
	my @values = @flatopts[1,3...*].map(&EVAL);
	my @cfgopts = do given @opts.elems {
		when 0 { ("") }
		when 1 { @values[0].map({ "@opts[0]=$_" }) }
		default {
			[X] @values ==> map({ @opts Z $_ }) # generate permutations
			            ==> map({ $_>>.map(&msafe)>>.join('=').join(':') }) # stringify
		}
	}

	note("Trying {@cfgopts.elems || 1} permutations...");
	note(@cfgopts.raku) if %gbl<verbose>;

	@cfgopts.map(&test);

	if %gbl<statsfile> {
		%gbl<statsfile>.close();
		note("\nSorted worst to best:\n");
		run(<sort -k 2 -n>, :in(open %gbl<statsfile>.IO.path), :out)
			.out.slurp(:close).split("\n")
			==> { .elems < 15 ?? $_ !! $_[*-15..*] }() # last 15 or less
			==> join("\n") ==> note();

		run <bzip2 -9>, ('-f' if $force), %gbl<statsfile>.IO.path;
	}
}

