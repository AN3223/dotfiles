#!/usr/bin/awk -f

# XXX better support multi-stage shader templates?
# XXX implement guided_cfg's featureset
# XXX implement a directive for setting option defaults
# XXX be cautious about for (i in array) syntax, order is unspecified
# XXX maybe don't take options from environment variables

function basename(s) {
	sub("/$", "", s)
	gsub(".*/", "", s)
	return s
}

function trim(s) { sub(/^[[:space:]]*/, "", s); return s; }

# XXX assumes locale's radix is .
# XXX doesn't handle hexadecimal representations of zero
function is_num(x) {
	if (is_obviously_num = x+0 == x)
		return is_obviously_num
	x = trim(x)
	is_str_zero = x ~ /^[+-]?(0+\.?0*|\.0+)([eE][+-]?[0-9]+)?/
	return (x+0 == int(x)) && (int(x) != 0 || is_str_zero)
}

function ensure_cfg_opts() {
	if (!CFGOPTS)
		split(argv("OPTS"), CFGOPTS, ":")
}

# XXX handle absence of OPTS_PLANE
function ensure_cfg_plane_opts() {
	ensure_cfg_opts()
	if (!CFGOPTS_PLANE)
		split(argv(OPTS_PLANE) ":" argv("OPTS"), CFGOPTS_PLANE, ":")
}

function get_opt(k) {
	ensure_cfg_opts()
	for (i in CFGOPTS) {
		split(CFGOPTS[i], kv, "=")
		if (kv[1] == k)
			return kv[2]
	}
}

function hooks() {
	if (!HOOKS) {
		# XXX read this default from the template
		HOOKS = "LUMA,CHROMA"
		hooks = get_opt("CFG_HOOKS")
		if (hooks)
			HOOKS = hooks
	}
	split(HOOKS, hooks_arr, ",")
	for (i in hooks_arr)
		print("//!HOOK", hooks_arr[i])
}

function register_tex(tex) {
	for (i in TEXTURES)
		if (TEXTURES[i] == tex) # avoid double binds
			return
	TEXTURES[++TEXTURES_LEN] = tex
}

function argv(var) {
	for (i in ARGV) {
		if (ARGV[i] ~ /^[_[:alpha:]][_[:alnum:]]*=/ && ARGV[i] ~ ("^" var)) {
			kv = ARGV[i]
			sub(/^[_[:alpha:]][_[:alnum:]]*=/, "", kv)
			return kv
		}
	}
	return ENVIRON["CFG_" var]
}

BEGIN {
	TEXTURES_LEN = split("HOOKED", TEXTURES)
}

/\/\/cfg_desc/ { print("// ", argv("DESC")); next; }
/\/\/cfg_name/ { $1 = ""; NAME = substr($0, 2); next; }

/\/\/cfg_hook/ {
	hooks()
	for (i in TEXTURES)
		print("//!BIND", TEXTURES[i])

	desc = argv("DESC")
	split(desc, desc_words)
	sub(/:$/, "", desc_words[1])
	print("//!DESC", NAME, "(" desc_words[1] ")")

	if (!SIZE)
		SIZE = get_opt("CFG_SIZE")

	if (size = SIZE) {
		op = (size ~ /\//) ? "/" : "*"
		sub(/^[\*\/]/, "", size)

		if (is_num(size)) {
			print("//!WIDTH", "HOOKED.w", size, op)
			print("//!HEIGHT", "HOOKED.h", size, op)
		} else {
			print("//!WIDTH", size ".w")
			print("//!HEIGHT", size ".h")
		}
	}
	
	next
}

function cfg_tex(save, desc, size) {
	if (size ~ /^PRE/) {
		sub(/^PRE/, "", size)
		cfg_tex("PRE" save, "PRE" desc, size)
		bind = "PRE" save
		size = "HOOKED"
	} else {
		save_ = get_opt(save)
		sub(/^PRE/, "", save_)
		if (save_)
			save = save_
		bind = "HOOKED"
	}

	op = (size ~ /\//) ? "/" : "*"
	scale = size
	sub(/[\*\/]/, "", scale)

	if (is_num(scale)) {
		hooks()
		print("//!BIND", bind)
		print("//!WIDTH", "HOOKED.w", scale, op)
		print("//!HEIGHT", "HOOKED.h", scale, op)
	} else if (size ~ /^SHARE_/) {
		# XXX should this (have the option to) scale?
		hooks()
		sub(/^SHARE_/, "", size)
		print("//!BIND", bind = size)
		desc = desc ", share"
	} else if (size ~ /\//) {
		inject_opts_len = split("", inject_opts)
		inject_opts_str = ""
		ensure_cfg_opts()
		for (i in CFGOPTS) {
			if (CFGOPTS[i] ~ /^INJ_/) {
				opt = CFGOPTS[i]
				sub(/^INJ_/, "", opt)
				inject_opts_str = sprintf("%s:%s", inject_opts_str, opt)
			}
		}
		sub(/^:/, "", inject_opts_str)

		shader = size
		cmd = sprintf("./inject_shader -v OUT_TEX=%s -v HOOKS=%s", save, HOOKS)
		if (inject_opts_str)
			cmd = sprintf("./shader_cfg %s CFG_OPTS=%s | %s", shader, inject_opts_str, cmd)
		else
			cmd = sprintf("%s < %s", cmd, shader)

		print("// The following is shader code injected from", basename(shader))
		system(cmd)
		print("// End of source code injected from", basename(shader))

		register_tex(save)
		return
	} else { # plain old texture name
		hooks()
		print("//!BIND", bind)
		print("//!WIDTH", size ".w")
		print("//!HEIGHT", size ".h")
	}

	print("//!DESC", NAME, "(" desc ")")
	print("//!SAVE", save)
	printf("\nvec4 hook()\n{\n\treturn %s_texOff(0);\n}\n\n", bind)

	if (save !~ /^PRE/)
		register_tex(save)
}

# usage: //cfg_tex SAVE=tex_name DESC=tex_desc SIZE=size
#
# Order of parameters doesn't matter
#
# SIZE is user configurable by using SAVE's value as an option.
#
# SIZE may be:
# 	- A scaling factor like *2 or 2* or /2 or 2/
# 		- If the operator is omitted it will default to *
# 		- A prefix of PRE scales the texture back to the size of HOOKED
# 			- This part isn't user configurable, since it could break shader code
# 	- A file name of a shader to derive the texture from
# 		- Must contain a / or a ./ to be considered a shader file
# 	- A texture name prefixed by SHARE_
# 		- Saves a copy of the specified texture
# 	- A texture name
# 		- Scales HOOKED to the size of the specified texture
#
/^\/\/cfg_tex/ {
	# XXX support range()
	$1 = ""; params = substr($0, 2);
	split(params, params)
	for (i in params) {
		split(params[i], kv, "=")
		if (kv[1] == "SAVE")
			save = kv[2]
		else if (kv[1] == "DESC")
			desc = kv[2]
		else if (kv[1] == "SIZE")
			size = kv[2]
	}
	cfg_tex(save, desc, size)
	next
}

# XXX unset this between stages
# XXX make it possible for the user to force disable this
tolower($0) ~ /^\/[\/\*].*shader code/ { SHADER_CODE = 1 }

/^#(el)?ifdef [_[:alpha:]][_[:alnum:]]*_raw$/ {
	OPTS_PLANE = $2
	sub(/_raw$/, "", OPTS_PLANE)
	split("", CFGOPTS_PLANE)
}
/^#else/ {
	OPTS_PLANE = "OTHER"
	split("", CFGOPTS_PLANE)
}
/^#define/ && !SHADER_CODE {
	ensure_cfg_plane_opts()
	for (i in CFGOPTS_PLANE) {
		split(CFGOPTS_PLANE[i], kv, "=")
		if ($2 == kv[1]) {
			print($1, kv[1], kv[2])
			next
		}
	}
}

function int_or_opt(x) { return is_num(x) ? x+0 : get_opt(x) }

# usage: range("assignments template_str")
#
# Returns a string with a line for each element in the longest of the specified 
# ranges, where each line is "template_str" with each occurrence of ${variable} 
# replaced with its corresponding value.
#
# ...e.g., range("i=1...10; ${i}") -> "1\n2\n3\n4\n5\n6\n7\n8\n9\n10"
#
# "assignments" is an optional semicolon delimited+terminated list of the form:
# variable=value; variable=value;
#
# "variable" is an arbitrary name
#
# "value" must be one of three forms:
# 	- value
# 		- Either a number or an option name to be substituted w/ its value
# 	- start...stop
# 		- E.g., 1...10 to generate a series from 1 to 10
# 		- "start" and "stop" are both "values", so option names are legal
# 	- start,next...stop
# 		- Same as above, but the step size is "next" minus "start"
# 		- E.g., 2,4...10 to generate an even numbered series up to 10
# 		- "next" is a "value" too
#
# "template_str" is a string optionally containing ${variable}
#
function range(s) {
	assignments_len = split(s, assignments, ";")

	# split template from assigments while preserving the template's semicolons
	# (technically allows for odd syntax, but shouldn't occur in regular use)
	template_str = ""
	for (i in assignments) {
		assignments[i] = trim(assignments[i])
		if (assignments[i] !~ /^[_[:alpha:]][_[:alnum:]]*=[_.[:alnum:]]+$/) {
			if (assignments[i])
				template_str = sprintf("%s\n%s", template_str, assignments[i])
			else
				template_str = template_str ";"
			delete assignments[i]
			assignments_len--;
		}
	}
	sub("^\n", "", template_str)

	if (!assignments_len) # nothing to do
		return template_str

	result = ""
	done = 0
	split("", var_states)
	while (!done) {
		done = 1 # done unless stated otherwise
		line = template_str
		for (i in assignments) {
			split(assignments[i], kv, "=")
			if (kv[2] !~ /\.\.\./) {
				if (!result)
					var_states[i] = int_or_opt(kv[2])
			} else {
				split(kv[2], startnext_stop, /\.\.\./)
				if (startnext_stop[1] ~ /,/) { # start,next...stop
					split(startnext_stop[1], start_next, ",")
					start = int_or_opt(start_next[1])
					stop = int_or_opt(startnext_stop[2])
					step = int_or_opt(start_next[2]) - start
				} else {                       # start...stop
					start = int_or_opt(startnext_stop[1])
					stop = int_or_opt(startnext_stop[2])
					step = (start < stop) ? 1 : -1
				}

				if (!result) { # first iteration of while loop
					var_states[i] = start
					done = 0
				} else if (step > 0 && var_states[i] < stop) {
					var_states[i] += step
					if (var_states[i] >= stop)
						var_states[i] = stop
					else
						done = 0
				} else if (step < 0 && var_states[i] > stop) {
					var_states[i] += step
					if (var_states[i] <= stop)
						var_states[i] = stop
					else
						done = 0
				}
			}
			gsub(sprintf("\\$\\{%s\\}", kv[1]), var_states[i], line)
		}
		result = sprintf("%s\n%s", result, line)
	}
	sub("^\n", "", result)
	return result
}

/\/\/cfg_range/ { $1 = ""; print(range(substr($0, 2))); next; }

# usage: //cfg_storage TEXTURE=name SIZE=width:height FORMAT=format
#
# The order of the parameters does matter
#
# Supports range() syntax
#
/\/\/cfg_storage/ {
	$1 = ""; params = range(substr($0, 2));
	lines_len = split(params, lines, "\n")
	for (line = 1; line <= lines_len; line++) {
		split(lines[line], assignments)
		for (j in assignments) {
			split(assignments[j], kv, "=")
			if (kv[1] == "TEXTURE") {
				register_tex(kv[2])
				TEXTURE_BLOCKS = sprintf("%s\n//!TEXTURE %s", TEXTURE_BLOCKS, kv[2])
			} else if (kv[1] == "SIZE") {
				sub(":", " ", kv[2])
				TEXTURE_BLOCKS = sprintf("%s\n//!SIZE %s", TEXTURE_BLOCKS, kv[2])
			} else if (kv[1] == "FORMAT") {
				TEXTURE_BLOCKS = sprintf("%s\n//!FORMAT %s", TEXTURE_BLOCKS, kv[2])
			}
		}
		TEXTURE_BLOCKS = sprintf("%s\n//!STORAGE\n", TEXTURE_BLOCKS)
	}
	sub("^\n", "", TEXTURE_BLOCKS)
	next
}

{ print($0) }

END {
	printf("%s", TEXTURE_BLOCKS)
}

