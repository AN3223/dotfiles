#!/usr/bin/awk -f

# XXX better support multi-stage shader templates?
# XXX implement guided_cfg's featureset

function basename(s) {
	sub("/$", "", s)
	gsub(".*/", "", s)
	return s
}

# XXX assumes locale's radix is .
# XXX doesn't handle hexadecimal representations of zero
function is_num(x) {
	sub(/^[[:space:]]*/, "", x)
	if (is_obviously_num = x+0 == x)
		return is_obviously_num
	is_str_zero = x ~ /^[+-]?(0+\.?0*|\.0+)([eE][+-]?[0-9]+)?/
	return (x+0 == int(x)) && (int(x) != 0 || is_str_zero)
}

function ensure_cfg_opts() {
	if (!cfg_opts)
		split(cfg_var("OPTS"), cfg_opts, ":")
}

function ensure_cfg_plane_opts() {
	ensure_cfg_opts()
	if (!cfg_plane_opts)
		split(cfg_var(opt_plane) ":" cfg_opts, cfg_plane_opts, ":")
}

function get_opt(k) {
	ensure_cfg_opts()
	for (i in cfg_opts) {
		split(cfg_opts[i], kv, "=")
		if (kv[1] == k)
			return kv[2]
	}
}

function hooks() {
	if (!HOOKS) {
		# XXX read this default from the template
		HOOKS = "LUMA,CHROMA"
		HOOKS_ = get_opt("CFG_HOOKS")
		if (HOOKS_)
			HOOKS = HOOKS_
	}
	split(HOOKS, HOOKS_ARR, ",")
	for (i in HOOKS_ARR)
		print("//!HOOK", HOOKS_ARR[i])
}

function register_tex(tex) {
	for (i in TEXTURES)
		if (TEXTURES[i] == tex) # avoid double binds
			return
	TEXTURES[++TEXTURES_LEN] = tex
}

function cfg_var(var) {
	for (i in ARGV) {
		if (ARGV[i] ~ /[_[:alpha:]][_[:alnum:]]*=/ && ARGV[i] ~ ("^CFG_" var "=")) {
			kv = ARGV[i]
			sub(/.*=/, "", kv)
			return kv
		}
	}
	return ENVIRON["CFG_" var]
}

BEGIN {
	TEXTURES_LEN = split("HOOKED", TEXTURES)
}

/\/\/cfg_desc/ { print("// Profile description:", cfg_var("DESC")); next; }
/\/\/cfg_name/ { $1 = ""; NAME = substr($0, 2); next; }

/\/\/cfg_hook/ {
	hooks()
	for (i in TEXTURES)
		print("//!BIND", TEXTURES[i])
	print("//!DESC", NAME, "(" FILENAME ")")

	if (!FINAL_SIZE)
		FINAL_SIZE = get_opt("CFG_SIZE")

	if (FINAL_SIZE_ = FINAL_SIZE) {
		sub(/^[\*\/]/, "", FINAL_SIZE_)
		op = (FINAL_SIZE ~ /^\//) ? "/" : "*"

		if (is_num(FINAL_SIZE_)) {
			print("//!WIDTH", "HOOKED.w", FINAL_SIZE_, op)
			print("//!HEIGHT", "HOOKED.h", FINAL_SIZE_, op)
		} else {
			print("//!WIDTH", FINAL_SIZE_ ".w")
			print("//!HEIGHT", FINAL_SIZE_ ".h")
		}
	}
}

function cfg_tex(SAVE, DESC, SIZE) {
	if (SIZE ~ /^PRE/) {
		sub(/^PRE/, "", SIZE)
		cfg_tex("PRE" SAVE, "PRE" DESC, SIZE)
		BIND = "PRE" SAVE
		SIZE = "HOOKED"
	} else {
		SAVE_ = get_opt(SAVE)
		sub(/^PRE/, "", SAVE_)
		if (SAVE_)
			SAVE = SAVE_
		BIND = "HOOKED"
	}

	op = (SIZE ~ /\//) ? "/" : "*"
	scale = SIZE
	sub(/[\*\/]/, "", scale)

	if (is_num(scale)) {
		hooks()
		print("//!BIND", BIND)
		print("//!WIDTH", "HOOKED.w", scale, op)
		print("//!HEIGHT", "HOOKED.h", scale, op)
	} else if (SIZE ~ /^SHARE_/) {
		# XXX should this (have the option to) scale?
		hooks()
		sub(/^SHARE_/, "", SIZE)
		print("//!BIND", BIND = SIZE)
		DESC = DESC ", share"
	} else if (SIZE ~ /\//) {
		inject_opts_len = split("", inject_opts)
		inject_opts_str = ""
		ensure_cfg_opts()
		for (i in cfg_opts)
			if (cfg_opts[i] ~ /^INJ_/)
				inject_opts[++inject_opts_len] = cfg_opts[i]
		if (inject_opts_len) {
			for (i in inject_opts) {
				sub(/^INJ/, "", inject_opts[i])
				if (!inject_opts_str)
					inject_opts_str = inject_opts[i]
				else
					inject_opts_str = inject_opts_str ":" inject_opts[i]
			}
		}

		shader = SIZE
		cmd = sprintf("./inject_shader -v OUT_TEX=%s -v HOOKS=%s", SAVE, HOOKS)
		if (inject_opts_str)
			cmd = sprintf("./shader_cfg %s CFG_OPTS=%s | %s", shader, inject_opts_str, cmd)
		else
			cmd = sprintf("%s < %s", cmd, shader)

		print("// The following is shader code injected from", basename(shader))
		system(cmd)
		print("// End of source code injected from", basename(shader))

		register_tex(SAVE)
		return
	} else { # plain old texture name
		hooks()
		print("//!BIND", BIND)
		print("//!WIDTH", SIZE ".w")
		print("//!HEIGHT", SIZE ".h")
	}

	print("//!DESC", NAME, "(" DESC ")")
	print("//!SAVE", SAVE)
	printf("\nvec4 hook()\n{\n\treturn %s_texOff(0);\n}\n\n", BIND)

	if (SAVE !~ /^PRE/)
		register_tex(SAVE)
}

# usage: //cfg_tex SAVE=tex_name DESC=tex_desc SIZE=size
#
# Order of parameters doesn't matter
#
# SIZE is user configurable by using SAVE's value as an option.
#
# SIZE may be:
# 	- A scaling factor like *2 or 2* or /2 or 2/
# 		- If the operator is omitted it will default to *
# 		- A prefix of PRE scales the texture back to the size of HOOKED
# 			- This part isn't user configurable, since it could break shader code
# 	- A file name of a shader to derive the texture from
# 		- Must contain a / or a ./ to be considered a shader file
# 	- A texture name prefixed by SHARE_
# 		- Saves a copy of the specified texture
# 	- A texture name
# 		- Scales HOOKED to the size of the specified texture
/^\/\/cfg_tex/ {
	$1 = ""; params = substr($0, 2);
	split(params, params)
	for (i in params) {
		split(params[i], kv, "=")
		if (kv[1] == "SAVE")
			SAVE = kv[2]
		else if (kv[1] == "DESC")
			DESC = kv[2]
		else if (kv[1] == "SIZE")
			SIZE = kv[2]
	}
	cfg_tex(SAVE, DESC, SIZE)
	next
}

tolower($0) ~ /^\/[\/\*].*shader code/ { shader_code = 1 }
/^#(el)?ifdef [_[:alpha:]][_[:alnum:]]*_raw$/ {
	opt_plane = $2
	sub(/_raw$/, "", opt_plane)
	split("", cfg_plane_opts)
}
/^#else/ {
	opt_plane = "OTHER"
	split("", cfg_plane_opts)
}
/^#define/ && !shader_code {
	ensure_cfg_plane_opts()
	for (i in cfg_plane_opts) {
		split(cfg_plane_opts[i], kv, "=")
		if ($2 == kv[1]) {
			print($1, kv[1], kv[2])
			next
		}
	}
}

function int_or_get_opt(x) { return is_num(x) ? x+0 : get_opt(x) }

function condition(l, op, r) {
	l = (l == assignments[1]) ? for_i : int_or_get_opt(l)
	r = (r == assignments[1]) ? for_i : int_or_get_opt(r)
	if (op == "<")
		return l < r
	else if (op == "<=")
		return l <= r
	else if (op == "!=")
		return l != r
	else if (op == "==")
		return l == r
	else if (op == ">")
		return l > r
	else if (op == ">=")
		return l >= r
}

# XXX support += and -=
function increment(s) {
	if (index(s, "++"))
		return for_i++
	else if (index(s, "--"))
		return for_i--
	system("echo invalid //cfg_for increment >&2")
	exit 1
}

# usage: //cfg_for (i = value; i operator value; incr) text
#
# value may be either an integer or an option from CFG_OPTS
#
# incr may be i++ or ++i
#
# operator may be any of the comparison operators
#
# text is the result with ${i} to stand in for values
#
# i may be any arbitary text; it serves as a variable name
/\/\/cfg_for/ {
	$1 = ""; params = substr($0, 2);
	body = parenthesized = params
	gsub(/(\(|\).*)/, "", parenthesized)
	gsub(/.*\)[[:space:]]*/, "", body)

	split(parenthesized, statements, ";")
	l1 = split(statements[1], assignments)
	l2 = split(statements[2], conditions)
	l3 = split(statements[3], increments)

	if (l1 > 3 || assignments[2] != "=") {
		system("echo invalid //cfg_for assignment >&2")
		exit 1
	} else if (!l2) {
		system("echo infinite //cfg_for loops are a bad idea >&2")
		exit 1
	} else if (l2 > 3) {
		system("echo too many args for //cfg_for condition >&2")
		exit 1
	} else if (l3 > 1) {
		system("echo too many args for //cfg_for increment >&2")
		exit 1
	}

	for (for_i = int_or_get_opt(assignments[3]); condition(conditions[1], conditions[2], conditions[3]); increment(increments[1])) {
		body_ = body
		gsub(sprintf("\\${%s}", assignments[1]), for_i, body_)
		print(body_)
	}

	next
}

# XXX make a directive for generating a series of storage textures (needs to be above cfg_hook in template)

{ print($0) }

