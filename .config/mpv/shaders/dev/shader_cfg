#!/usr/bin/awk -f

# XXX implement guided_cfg's featureset
# XXX merge with inject_shader? lots of duplicate functionality
# XXX could really use a refactor

function basename(s) {
	sub("/$", "", s)
	gsub(".*/", "", s)
	return s
}

function trim(s) { sub(/^[[:space:]]*/, "", s); return s; }

# XXX assumes locale's radix is .
# XXX doesn't handle hexadecimal representations of zero
function is_num(x,    is_obviously_num, is_str_zero) {
	if (is_obviously_num = x+0 == x)
		return is_obviously_num
	x = trim(x)
	is_str_zero = x ~ /^[+-]?(0+\.?0*|\.0+)([eE][+-]?[0-9]+)?/
	return (x+0 == int(x)) && (int(x) != 0 || is_str_zero)
}

function ensure_cfg_opts(    cfgopts) {
	if (CFGOPTS_LEN)
		return
	cfgopts = argv("OPTS") ":" DEFAULTS
	sub(/^:/, "", cfgopts)
	CFGOPTS_LEN = split(cfgopts, CFGOPTS, ":")
}

function ensure_cfg_plane_opts(    concat, i) {
	if (CFGOPTS_PLANE_LEN)
		return

	concat = ""
	ensure_cfg_opts()

	# stringify CFGOPTS, since it may have been modified
	if (CFGOPTS_LEN) {
		for (i = 1; i <= CFGOPTS_LEN; i++)
			concat = concat ":" CFGOPTS[i]
		sub("^:", "", concat)
	}

	if (OPTS_PLANE) {
		concat = argv("OPTS_" OPTS_PLANE) ":" concat
		sub(":$", "", concat)
	}

	CFGOPTS_PLANE_LEN = split(concat, CFGOPTS_PLANE, ":")
}

# get_opt(opt) will simply return the opt's value
# get_opt(opt, val) will also set the opt's value to "val"
function get_opt(k, v,    i, kv) {
	ensure_cfg_opts()
	for (i = 1; i <= CFGOPTS_LEN; i++) {
		split(CFGOPTS[i], kv, "=")
		if (kv[1] == k) {
			if (v) {
				# set value and recompute CFGOPTS_PLANE
				CFGOPTS[i] = k "=" v
				CFGOPTS_PLANE_LEN = 0
				ensure_cfg_plane_opts()
			}
			return kv[2]
		}
	}
}

function ensure_hooks() {
	if (!HOOKS)
		HOOKS = get_opt("CFG_HOOKS")
}

function hooks(    i, hooks) {
	ensure_hooks()
	split(HOOKS, hooks, ",")
	for (i in hooks)
		print("//!HOOK", hooks[i])
}

function register_tex(tex,    i) {
	for (i in TEXTURES)
		if (TEXTURES[i] == tex) # avoid double binds
			return
	TEXTURES[++TEXTURES_LEN] = tex
}

function argv(var,    i, kv) {
	for (i in ARGV) {
		if (ARGV[i] ~ /^[_[:alpha:]][_[:alnum:]]*=/ && ARGV[i] ~ ("^" var)) {
			kv = ARGV[i]
			sub(/^[_[:alpha:]][_[:alnum:]]*=/, "", kv)
			return kv
		}
	}
}

function parse_size(size, parsed_size) {
	parsed_size["OPERATOR"] = (size ~ "/") ? "/" : "*"
	sub("[*/]", "", size)
	parsed_size["SCALE"] = size
}

BEGIN {
	TEXTURES_LEN = split("HOOKED", TEXTURES)
}

# record is part of a HOOK block
$0 ~ "^//!" {
	HOOK_LINES[++HOOK_LEN] = $0
	sub("^//!", "")
	directive = $1; $1 = "";
	HOOK_DIRECTIVES[directive] = trim($0)
	next
}

# end of HOOK block
$0 !~ "^//!" && HOOK_LEN {
	hooks()

	# take an optional user parameter
	size = HOOK_DIRECTIVES["SAVE"] ? get_opt(HOOK_DIRECTIVES["SAVE"]) : ""

	# print HOOK_LINES besides //!HOOK, and besides //!(WIDTH|HEIGHT) if size
	for (i = 1; i <= HOOK_LEN; i++)
		if (HOOK_LINES[i] !~ "^//!HOOK")
			if (!size || HOOK_LINES[i] !~ "^//!(WIDTH|HEIGHT)")
				print(HOOK_LINES[i])

	split("", parsed_size)
	parse_size(size, parsed_size)
	if (size && is_num(parsed_size["SCALE"])) {
		# determine the relevant texture from existing WIDTH/HEIGHT directives
		# XXX ideally cfg_tex should have this functionality too
		try_get_tex = HOOK_DIRECTIVES["HEIGHT"] ? HOOK_DIRECTIVES["HEIGHT"] : HOOK_DIRECTIVES["WIDTH"]
		split(try_get_tex, try_get_tex_words)
		sub(/\../, "", try_get_tex_words[1])
		tex = try_get_tex_words[1] ? try_get_tex_words[1] : "HOOKED"

		print("//!WIDTH", tex ".w", parsed_size["SCALE"], parsed_size["OPERATOR"])
		print("//!HEIGHT", tex ".h", parsed_size["SCALE"], parsed_size["OPERATOR"])
	} else if (size) {
		print("//!WIDTH", size ".w")
		print("//!HEIGHT", size ".h")
	}
}

# not a hook block, reset any hook block related stuff
$0 !~ "^//!" { HOOK_LEN = 0; split("", HOOK_DIRECTIVES); split("", HOOK_LINES); }

/^\/\/cfg_desc/ {
	$1 = ""; params = trim($0);
	if (argv("DESC"))
		$0 = argv("DESC")
	else
		$0 = $0 # re-splits $0

	$1 = basename($1)
	DESC = $0
	print("// Description:", DESC)
	next
}
/^\/\/cfg_name/ { $1 = ""; NAME = trim($0); next; }

# XXX need a way to do this per plane
/^\/\/cfg_defaults/ { $1 = ""; DEFAULTS = trim($0); next; }

# XXX better support multi-stage shader templates?
# XXX generalize this, maybe via cfg_tex()?
/^\/\/cfg_hook/ {
	hooks()
	for (i in TEXTURES)
		print("//!BIND", TEXTURES[i])

	split(DESC, desc_words)
	sub(/:$/, "", desc_words[1])
	print("//!DESC", NAME, "(" desc_words[1] ")")

	if (!SIZE)
		SIZE = get_opt("CFG_SIZE")

	if (SIZE) {
		split("", parsed_size)
		parse_size(SIZE, parsed_size)

		if (is_num(parsed_size["SCALE"])) {
			print("//!WIDTH", "HOOKED.w", parsed_size["SCALE"], parsed_size["OPERATOR"])
			print("//!HEIGHT", "HOOKED.h", parsed_size["SCALE"], parsed_size["OPERATOR"])
		} else {
			print("//!WIDTH", SIZE ".w")
			print("//!HEIGHT", SIZE ".h")
		}
	}
	
	next
}

# XXX need to handle PRE + non PRE scaling to support guided_lgc
function cfg_tex(save, desc, size, copy,    bind, op, scale, opt, inject_opts, shader, cmd, parsed_size) {
	size_ = get_opt(save)
	if (size_ != 0)
		get_opt(save, 1) # e.g., RF=SHARE_LUMA sets the RF macro to 1
	else
		return get_opt(save, 0) # e.g., RF=0 sets the RF macro to 0

	if (size_ != "")
		size = size_
	bind = copy ? copy : "HOOKED"

	if (size ~ /^PRE/) {
		sub(/^PRE/, "", size)
		cfg_tex("PRE" save, "PRE" desc, size, "HOOKED")
		bind = "PRE" save
		size = "HOOKED"
	}

	split("", parsed_size)
	parse_size(size, parsed_size)

	if (is_num(parsed_size["SCALE"])) {
		hooks()
		print("//!BIND", bind)
		print("//!WIDTH", bind ".w", parsed_size["SCALE"], parsed_size["OPERATOR"])
		print("//!HEIGHT", bind ".h", parsed_size["SCALE"], parsed_size["OPERATOR"])
	} else if (size ~ /^SHARE_/) {
		# XXX should scaling here be configurable?
		hooks()
		sub(/^SHARE_/, "", size)
		print("//!BIND", bind = size)
		print("//!WIDTH", bind ".w")
		print("//!HEIGHT", bind ".h")
		desc = desc ", share"
	} else if (size ~ /\//) {
		inject_opts = ""
		ensure_hooks()
		ensure_cfg_opts()
		for (i = 1; i < CFGOPTS_LEN; i++) {
			if (CFGOPTS[i] ~ /^INJ_/) {
				opt = CFGOPTS[i]
				sub(/^INJ_/, "", opt)
				inject_opts = sprintf("%s:%s", inject_opts, opt)
			}
		}
		sub(/^:/, "", inject_opts)

		shader = size
		cmd = sprintf("./inject_shader -v OUT_TEX=%s -v HOOKS=%s", save, HOOKS)
		if (inject_opts)
			cmd = sprintf("./shader_cfg %s OPTS=%s | %s", shader, inject_opts, cmd)
		else
			cmd = sprintf("%s < %s", cmd, shader)

		print("// The following is shader code injected from", basename(shader))
		system(cmd)
		print("// End of source code injected from", basename(shader), "\n")

		register_tex(save)
		return
	} else { # size is either a texture name or null
		hooks()
		print("//!BIND", bind)
		if (size) {
			print("//!WIDTH", size ".w")
			print("//!HEIGHT", size ".h")
		}
	}

	print("//!DESC", NAME, "(" desc ")")
	print("//!SAVE", save)
	if (copy)
		printf("\nvec4 hook()\n{\n\treturn %s_texOff(0);\n}\n\n", bind)

	if (save !~ /^PRE/)
		register_tex(save)
}

# usage: //cfg_tex SAVE=tex_name DESC=tex_desc SIZE=size COPY=copy
#
# Order of parameters doesn't matter
#
# SIZE is user configurable by using SAVE's value as an option.
#
# SIZE may be:
# 	- A scaling factor like *2 or 2* or /2 or 2/
# 		- If the operator is omitted it will default to *
# 		- A prefix of PRE scales the texture back to the size of HOOKED
# 	- A file name of a shader to derive the texture from
# 		- Must contain a / or a ./ to be considered a shader file
# 	- A texture name prefixed by SHARE_
# 		- Saves a copy of the specified texture
# 	- A texture name
# 		- Scales to the size of the specified texture
#
# If COPY is set to a texture name then a minimal hook() will be generated that 
# will BIND to that texture and sample from it
#
/^\/\/cfg_tex/ {
	# XXX support range()
	$1 = ""; params = trim($0);
	split(params, params)
	for (i in params) {
		split(params[i], kv, "=")
		if (kv[1] == "SAVE")
			save = kv[2]
		else if (kv[1] == "DESC")
			desc = kv[2]
		else if (kv[1] == "SIZE")
			size = kv[2]
		else if (kv[1] == "COPY")
			copy = kv[2]
	}
	cfg_tex(save, desc, size, copy)
	next
}

# XXX unset this between stages
# XXX make it possible for the user to force disable this
tolower($0) ~ /^\/[\/\*].*shader code/ { SHADER_CODE = 1 }

/^#(el)?ifdef [_[:alpha:]][_[:alnum:]]*_raw$/ {
	OPTS_PLANE = $2
	sub(/_raw$/, "", OPTS_PLANE)
	CFGOPTS_PLANE_LEN = 0
}
/^#else/ {
	OPTS_PLANE = "OTHER"
	CFGOPTS_PLANE_LEN = 0
}
/^#define/ && !SHADER_CODE {
	ensure_cfg_plane_opts()
	for (i = 1; i <= CFGOPTS_PLANE_LEN; i++) {
		split(CFGOPTS_PLANE[i], kv, "=")
		if ($2 == kv[1]) {
			print($1, kv[1], kv[2])
			next
		}
	}
}

function int_or_opt(x) { return is_num(x) ? x+0 : get_opt(x)+0 }

# usage: range("directives template_str")
#
# Returns a string with a line for each element in the longest of the specified 
# ranges, where each line is "template_str" with each occurrence of ${variable} 
# replaced with its corresponding value.
#
# ...e.g., range("i=1...10; ${i}") -> "1\n2\n3\n4\n5\n6\n7\n8\n9\n10"
#
# "directives" is an optional semicolon delimited+terminated list containing:
# 	- An assignment of the form: variable=value
# 	- A condition of the form: if opt
# 		- The value of option "opt" will be retrieved and tested for truthiness
# 		- If the value is falsey, then range() will return nothing
#
# "variable" is an arbitrary name
#
# "value" must be one of three forms:
# 	- value
# 		- Either a number or an option name to be substituted w/ its value
# 	- start...stop
# 		- E.g., 1...10 to generate a series from 1 to 10
# 		- "start" and "stop" are both "values", so option names are legal
# 	- start,next...stop
# 		- Same as above, but the step size is "next" minus "start"
# 		- E.g., 2,4...10 to generate an even numbered series up to 10
# 		- "next" is a "value" too
#
# "template_str" is a string optionally containing ${variable}
#
function range(s,    param, param_len, param_words, template_str, i, vars, var_states, var, kv, result, done, line, startnext_stop, start_next) {
	param_len = split(s, param, ";")

	# split template from assigments while preserving the template's semicolons
	# (technically allows for odd syntax, but shouldn't occur in regular use)
	template_str = ""
	for (i in param) {
		param[i] = trim(param[i])
		if (param[i] ~ /^[_[:alpha:]][_[:alnum:]]*=[_.[:alnum:]]+$/) {
			continue
		} else if (param[i] ~ /^if [_[:alpha:]][_[:alnum:]]*$/) {
			split(param[i], param_words)
			if (!get_opt(param_words[2]))
				return ""
			else
				continue
		}

		# any other forms are considered fragments of the template_str
		if (param[i])
			template_str = sprintf("%s\n%s", template_str, param[i])
		else
			template_str = template_str ";"
		delete param[i]
		param_len--
	}
	sub("^\n", "", template_str)

	if (!param_len) # nothing to do
		return template_str
	
	split("", vars)
	split("", var_states)
	for (i in param) { # parse ranges
		split(param[i], kv, "=")
		vars[kv[1]] = kv[2]

		if (kv[2] !~ /\.\.\./) {
			var_states[kv[1]] = int_or_opt(kv[2])
		} else {
			split(kv[2], startnext_stop, /\.\.\./)
			if (startnext_stop[1] ~ /,/) { # start,next...stop
				split(startnext_stop[1], start_next, ",")
				var_states[kv[1] "start"] = int_or_opt(start_next[1])
				var_states[kv[1] "stop"] = int_or_opt(startnext_stop[2])
				var_states[kv[1] "step"] = int_or_opt(start_next[2]) - var_states[kv[1] "start"]
			} else {                       # start...stop
				var_states[kv[1] "start"] = int_or_opt(startnext_stop[1])
				var_states[kv[1] "stop"] = int_or_opt(startnext_stop[2])
				var_states[kv[1] "step"] = (var_states[kv[1] "start"] < var_states[kv[1] "stop"]) ? 1 : -1
			}
			var_states[kv[1]] = var_states[kv[1] "start"]
		}
	}

	result = ""
	done = 0
	while (!done) {
		done = 1 # done unless stated otherwise
		line = template_str
		for (var in vars) {
			if (!result) { # first iteration of while loop
				done = 0
			} else if (var_states[var "step"] > 0 && var_states[var] < var_states[var "stop"]) {
				var_states[var] += var_states[var "step"]
				if (var_states[var] >= var_states[var "stop"])
					var_states[var] = var_states[var "stop"]
				else
					done = 0
			} else if (var_states[var "step"] < 0 && var_states[var] > var_states[var "stop"]) {
				var_states[var] += var_states[var "step"]
				if (var_states[var] <= var_states[var "stop"])
					var_states[var] = var_states[var "stop"]
				else
					done = 0
			}
			gsub(sprintf("\\$\\{%s\\}", var), var_states[var], line)
		}
		result = sprintf("%s\n%s", result, line)
	}
	sub("^\n", "", result)
	return result
}

# XXX preserve the comment's indentation
/\/\/cfg_range/ { $1 = ""; print(range(trim($0))); next; }

# usage: //cfg_storage TEXTURE=name SIZE=id=widthxheight FORMAT=format
#
# The order of the parameters does matter
#
# Supports range() syntax
#
/^\/\/cfg_storage/ {
	$1 = ""; params = range(trim($0));
	lines_len = split(params, lines, "\n")
	for (line = 1; line <= lines_len; line++) {
		split(lines[line], assignments)
		for (j in assignments) {
			split(assignments[j], kv, "=")
			if (kv[1] == "TEXTURE") {
				register_tex(kv[2])
				TEXTURE_BLOCKS = sprintf("%s\n//!TEXTURE %s", TEXTURE_BLOCKS, kv[2])
			} else if (kv[1] == "SIZE") {
				opt = get_opt(kv[2])
				if (!opt)
					opt = kv[3]
				sub("x", " ", opt)
				TEXTURE_BLOCKS = sprintf("%s\n//!SIZE %s", TEXTURE_BLOCKS, opt)
			} else if (kv[1] == "FORMAT") {
				TEXTURE_BLOCKS = sprintf("%s\n//!FORMAT %s", TEXTURE_BLOCKS, kv[2])
			}
		}
		TEXTURE_BLOCKS = sprintf("%s\n//!STORAGE\n", TEXTURE_BLOCKS)
	}
	sub("^\n", "", TEXTURE_BLOCKS)
	next
}

{ print($0) }

END {
	printf("%s", TEXTURE_BLOCKS)
}

