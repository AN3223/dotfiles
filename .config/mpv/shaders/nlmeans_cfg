#!/usr/bin/awk -f
# This script modifies/generates preprocessor/GLSL code for nlmeans. Usage 
# examples can be found in Makefile.nlm

BEGIN {
	HOOKS = "LUMA:CHROMA:RGB"

	split(ENVIRON["CFG"], opts, ":")
	for (i in opts) {
		split(opts[i], var_val, "=")
		if (var_val[1] == "HOOKS")
			HOOKS = var_val[2]
		else if (var_val[1] == "T_FRAME_LIMIT")
			T_FRAME_LIMIT = var_val[2]
		else if (var_val[1] == "T_RES_W")
			T_RES_W = var_val[2]
		else if (var_val[1] == "T_RES_H")
			T_RES_H = var_val[2]
		else if (var_val[1] == "WIDTH")
			WIDTH = var_val[2]
		else if (var_val[1] == "HEIGHT")
			HEIGHT = var_val[2]
	}
}

/\/\/cfg_desc/ { printf("// Profile description: %s\n", ENVIRON["DESC"]); next; }

# Prints //!HOOK for each HOOKED plane and //!BIND HOOKED
function hooks(no_bind) {
	split(HOOKS, hooks_arr, ":")
	for (i in hooks_arr)
		printf("//!HOOK %s\n", hooks_arr[i])
	if (!no_bind)
		printf("%s\n", "//!BIND HOOKED")
}

# XXX handle TEXTURE blocks
function inject_shader(shader, tex_name) {
	print("// The following is shader code injected from " shader)
	shader_hook = shader_save = 0
	split("", intern_texs) # arr of internal texture names
	while (getline line < shader == 1) {
		split(line, words, "[[:space:]]")
		if (words[1] == "//!HOOK") { 
			if (!shader_hook) {
				shader_hook = 1 # mark start of HOOK block
				hooks(1) # inject our hooks into the shader
			}
			continue
		} else if (words[1] == "//!WHEN") {
			continue
		} else if (words[1] == "//!SAVE") {
			shader_save = 1
			intern_texs[length(intern_texs)+1] = words[2]
			print(words[1], "INJCT_" words[2])
			continue
		} else if (line !~ /^\/\/!/) { 
			if (shader_hook && !shader_save) # end of final HOOK block
				print("//!SAVE " tex_name)
			shader_hook = shader_save = 0
		}

		# prefix all occurrences of internal texture names
		for (i in intern_texs) {
			done = ""
			needle = shader_hook ? intern_texs[i] : intern_texs[i] "_" # lax query within HOOK blocks
			while (idx = index(line, needle)) {
				if (idx == 1 || substr(line, idx-1, 1) ~ /[[:space:](]/) {
					done = done substr(line, 1, idx-1) "INJCT_" needle
					line = substr(line, idx + length(needle))
				} else {
					done = done substr(line, 1, idx-1) needle
					line = substr(line, idx + length(needle))
				}
			}
			line = done line
		}

		print(line)
	}

	print("// End of source code injected from " shader)
}

function extremes_preserve(scale) {
	hooks(1)
	printf("%s\n%s\n%s\n%s\n%s\n\n%s\n%s\n%s\n%s\n\n",
		"//!DESC Non-local means (downscale)",
		"//!WIDTH LUMA.w " scale " /",
		"//!HEIGHT LUMA.h " scale " /",
		"//!BIND LUMA",
		"//!SAVE EP",
		"vec4 hook()",
		"{",
		"	return LUMA_texOff(0);",
		"}")
	TEXTURES = TEXTURES ? (TEXTURES ":" "EP") : "EP"
}

# XXX EP split into another function; could probably simplify this a lot
function robust_filter(name, scale) {
	prefixed_name = (name ~ /^RF/) ? ("PRE" name) : (name)
	if (scale ~ /^SHARE_/) {
		sub("SHARE_", "", scale)
		hooks()
		printf("%s\n%s\n%s\n\n%s\n%s\n%s\n%s\n\n",
			"//!DESC Non-local means (share)",
			"//!BIND " scale,
			"//!SAVE " name,
			"vec4 hook()",
			"{",
			"	return " scale "_texOff(0);",
			"}")
	} else if (scale !~ /^[0-9][.]?[0-9]*$/) {
		inject_shader(scale, name)
	} else {
		hooks()
		printf("%s\n%s\n%s\n%s\n\n%s\n%s\n%s\n%s\n\n",
			"//!DESC Non-local means (downscale)",
			"//!SAVE " prefixed_name,
			"//!WIDTH HOOKED.w " scale " /",
			"//!HEIGHT HOOKED.h " scale " /",
			"vec4 hook()",
			"{",
			"	return HOOKED_texOff(0);",
			"}")
		if (name ~ /^RF/) {
			hooks()
			printf("%s\n%s\n%s\n%s\n%s\n\n%s\n%s\n%s\n%s\n\n",
				"//!DESC Non-local means (unscale)",
				"//!BIND " prefixed_name,
				"//!SAVE " name,
				"//!WIDTH " (WIDTH ? WIDTH : "HOOKED.w"),
				"//!HEIGHT " (HEIGHT ? HEIGHT : "HOOKED.h"),
				"vec4 hook()",
				"{",
				"	return " prefixed_name "_texOff(0);",
				"}")
		}
	}
	
	TEXTURES = TEXTURES ? (TEXTURES ":" name) : name
}

# Shader stages preceding NLM
/\/\/cfg_pre/ {
	split("LUMA CHROMA", planes)
	for (p in planes) {
		# sets defaults for RF/EP, should be the same as nlmeans_template
		RF = (planes[p] == "LUMA") ? "guided.glsl" : "SHARE_RF_LUMA"
		EP = (planes[p] == "LUMA") ? 3.0 : 0

		RF_parsed = EP_parsed = 0 # prevent parsing opts multiple times
		split(ENVIRON[planes[p]], opts, ":")
		for (i in opts) {
			split(opts[i], var_val, "=")
			if (!RF_parsed && var_val[1] == "RF") {
				RF = var_val[2]
				RF_parsed = 1
			} else if (!EP_parsed && var_val[1] == "EP") {
				EP = var_val[2]
				EP_parsed = 1
			}
		}

		tex_suffix = (planes[p] == "LUMA") ? "_LUMA" : ""
		if (RF)
			robust_filter("RF" tex_suffix, RF)

		if (EP)
			extremes_preserve(EP)
	}
	next
}

# NLM HOOK block
/\/\/cfg_hook/ {
	hooks()

	split(TEXTURES, tex_arr, ":")
	for (i in tex_arr)
		printf("//!BIND %s\n", tex_arr[i])

	for (i = 1; i <= T_FRAME_LIMIT; i++)
		printf("//!BIND PREV%d\n", i)

	printf("//!DESC Non-local means (%s)\n", ENVIRON["FILENAME"])

	if (WIDTH)
		print("//!WIDTH " WIDTH)
	if (HEIGHT)
		print("//!HEIGHT " HEIGHT)

	next
}

/^#ifdef LUMA_raw$/       { plane = "LUMA" }
/^#el/ && plane == "LUMA" { plane = "CHROMA" }

/^#define/ {
	split(ENVIRON[plane], opts, ":")
	for (i in opts) {
		split(opts[i], var_val, "=")
		if ($2 == var_val[1]) {
			if ($2 ~ /^(RF|EP)$/)
				printf("#define %s %s\n", var_val[1], (var_val[2] > 0))
			else
				printf("#define %s %s\n", var_val[1], var_val[2])
			next
		}
	}
}

/\/\/cfg_T_load/ {
	for (i = 1; i <= T_FRAME_LIMIT; i++)
		printf("\tcase %d: return imageLoad(PREV%d, ivec2((HOOKED_pos + HOOKED_pt * vec2(off)) * imageSize(PREV%d)));\n", i, i, i)
	next
}

/\/\/cfg_T_store/ {
	for (i = T_FRAME_LIMIT; i > 0; i--)
		printf("\timageStore(PREV%d, ivec2(HOOKED_pos*imageSize(PREV%d)), load2(vec3(0,0,%d)));\n", i, i, i-1)
	next
}

{ print $0 }

END {
	for (i = 1; i <= T_FRAME_LIMIT; i++)
		printf("//!TEXTURE PREV%d\n//!SIZE %d %d\n//!FORMAT r32f\n//!STORAGE\n\n", i, T_RES_W, T_RES_H)
}

